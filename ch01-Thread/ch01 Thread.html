<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta charset="utf-8"/>

<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
<link rel="stylesheet" href="base.min.css"/>
<link rel="stylesheet" href="fancy.min.css"/>
<link rel="stylesheet" href="main.css"/>
<script src="compatibility.min.js"></script>
<script src="theViewer.min.js"></script>
<script>
try{
theViewer.defaultViewer = new theViewer.Viewer({});
}catch(e){}
</script>
<title></title>
</head>
<body>
<div id="sidebar">
<div id="outline">
</div>
</div>
<div id="page-container">
<div id="pf1" class="pf w0 h0" data-page-no="1"><div class="pc pc1 w0 h0"><img class="bi x0 y0 w1 h1" alt="" src="bg1.png"/><div class="c x0 y1 w2 h2"><div class="t m0 x1 h3 y2 ff1 fs0 fc0 sc0 ls0 ws0">鸟窝<span class="ff2"> - https://github.com/smallnest/concurrency-programming-via-rust</span></div></div><div class="c x0 y3 w2 h4"><div class="t m0 x2 h5 y4 ff3 fs1 fc0 sc0 ls0 ws0">第一章<span class="ff4"> Rust</span>并发编程基础：线程</div><div class="t m0 x2 h6 y5 ff3 fs2 fc0 sc0 ls0 ws0">线程<span class="ff1">（英语：<span class="ff5">thread</span>）是操作系统能够进行运算和调度的最小单位。大部分情况下，它被包含在</span></div><div class="t m0 x2 h6 y6 ff1 fs2 fc0 sc0 ls0 ws0">进程之中，是进程中的实际运作单位，所以说程序实际运行的时候是以线程为单位的，一个进程</div><div class="t m0 x2 h6 y7 ff1 fs2 fc0 sc0 ls0 ws0">中可以并发多个线程，每条线程并行执行不同的任务。</div><div class="t m0 x2 h6 y8 ff1 fs2 fc0 sc0 ls0 ws0">线程是独立调度和分派的基本单位，并且同一进程中的多条线程将共享该进程中的全部系统资</div><div class="t m0 x2 h6 y9 ff1 fs2 fc0 sc0 ls0 ws0">源，如虚拟地址空间，文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈</div><div class="t m0 x2 h6 ya ff1 fs2 fc0 sc0 ls0 ws0">（<span class="ff5">call stack</span>），自己的寄存器上下文（<span class="ff5">register context</span>），自己的线程本地存储（<span class="ff5">thread-local</span></div><div class="t m0 x2 h6 yb ff5 fs2 fc0 sc0 ls0 ws0">storage<span class="ff1">）。</span></div><div class="t m0 x2 h6 yc ff1 fs2 fc0 sc0 ls0 ws0">一个进程可以有很多线程来处理，每条线程并行执行不同的任务。如果进程要完成的任务很多，</div><div class="t m0 x2 h6 yd ff1 fs2 fc0 sc0 ls0 ws0">这样需很多线程，也要调用很多核心，在多核或多<span class="ff5">CPU</span>，或支持<span class="ff5">Hyper-threading</span>的<span class="ff5">CPU</span>上使用多</div><div class="t m0 x2 h6 ye ff1 fs2 fc0 sc0 ls0 ws0">线程程序设计可以提高了程序的执行吞吐率。在单<span class="ff5">CPU</span>单核的计算机上，使用多线程技术，也可</div><div class="t m0 x2 h6 yf ff1 fs2 fc0 sc0 ls0 ws0">以把进程中负责<span class="ff5">I/O</span>处理、人机交互而常被阻塞的部分与密集计算的部分分开来执行，从而提高</div><div class="t m0 x2 h6 y10 ff5 fs2 fc0 sc0 ls0 ws0">CPU<span class="ff1">的利用率。</span></div><div class="t m0 x2 h6 y11 ff1 fs2 fc0 sc0 ls0 ws0">线程在以下几个方面与传统的多任务操作系统进程不同：</div><div class="t m0 x3 h6 y12 ff1 fs2 fc0 sc0 ls0 ws0">进程通常是独立的，而线程作为进程的子集存在</div><div class="t m0 x3 h6 y13 ff1 fs2 fc0 sc0 ls0 ws0">进程携带的状态信息比线程多得多，而进程中的多个线程共享进程状态以及内存和其他资源</div><div class="t m0 x3 h6 y14 ff1 fs2 fc0 sc0 ls0 ws0">进程具有单独的地址空间，而线程共享其地址空间</div><div class="t m0 x3 h6 y15 ff1 fs2 fc0 sc0 ls0 ws0">进程仅通过系统提供的进程间通信机制进行交互</div><div class="t m0 x3 h6 y16 ff1 fs2 fc0 sc0 ls0 ws0">同一进程中线程之间的上下文切换通常比进程之间的上下文切换发生得更快</div><div class="t m0 x2 h6 y17 ff1 fs2 fc0 sc0 ls0 ws0">线程与进程的优缺点包括：</div><div class="t m0 x3 h6 y18 ff1 fs2 fc0 sc0 ls0 ws0">线程的资源消耗更少：使用线程，应用程序可以使用比使用多个进程时更少的资源来运行。</div><div class="t m0 x3 h6 y19 ff1 fs2 fc0 sc0 ls0 ws0">线程简化共享和通信：与需要消息传递或共享内存机制来执行进程间通信的进程不同，线程</div><div class="t m0 x3 h6 y1a ff1 fs2 fc0 sc0 ls0 ws0">可以通过它们已经共享的数据，代码和文件进行通信。</div><div class="t m0 x3 h6 y1b ff1 fs2 fc0 sc0 ls0 ws0">线程可以使进程崩溃：由于线程共享相同的地址空间，线程执行的非法操作可能会使整个进</div><div class="t m0 x3 h6 y1c ff1 fs2 fc0 sc0 ls0 ws0">程崩溃<span class="ff5">;</span>因此，一个行为异常的线程可能会中断应用程序中所有其他线程的处理。</div></div></div><div class="pi" data-data='{"ctm":[1.000000,0.000000,0.000000,1.000000,0.000000,0.000000]}'></div></div>
<div id="pf2" class="pf w0 h0" data-page-no="2"><div class="pc pc2 w0 h0"><img class="bi x0 y0 w3 h7" alt="" src="bg2.png"/><div class="c x0 y1 w2 h2"><div class="t m0 x1 h3 y2 ff1 fs0 fc0 sc0 ls0 ws0">鸟窝<span class="ff2"> - https://github.com/smallnest/concurrency-programming-via-rust</span></div></div><div class="c x0 y3 w2 h4"><div class="t m0 x2 h6 y1d ff1 fs2 fc0 sc0 ls0 ws0">更有一些编程语言，比如<span class="ff5">SmallT<span class="_ _0"></span>alk<span class="ff1">、</span>Ruby<span class="ff1">、</span>Lua<span class="ff1">、</span>Python<span class="ff1">等，还会有协程（英语：</span>coroutine<span class="ff1">）更</span></span></div><div class="t m0 x2 h6 y1e ff1 fs2 fc0 sc0 ls0 ws0">小的调度单位。协程非常类似于线程。但是协程是协作式多任务的，而线程典型是抢占式多任务</div><div class="t m0 x2 h6 y1f ff1 fs2 fc0 sc0 ls0 ws0">的。这意味着协程提供并发性而非并行性。使用抢占式调度的线程也可以实现协程，但是会失去</div><div class="t m0 x2 h6 y20 ff1 fs2 fc0 sc0 ls0 ws0">某些好处。<span class="ff5">Go</span>语言实现了<span class="ff5"> Goroutine </span>的最小调度单元，虽然官方不把它和<span class="ff5"> coroutine</span>等同，因为</div><div class="t m0 x2 h6 y21 ff5 fs2 fc0 sc0 ls0 ws0">goroutine <span class="ff1">实现了独特的调度和执行机制，但是你可以大致把它看成和协程是一类的东西。</span></div><div class="t m0 x2 h6 y22 ff1 fs2 fc0 sc0 ls0 ws0">还有一类更小的调度单元叫纤程（英语：<span class="ff5">Fiber</span>），它是一种最轻量化的线程。它是一种用户态线</div><div class="t m0 x2 h6 y23 ff1 fs2 fc0 sc0 ls0 ws0">程（<span class="ff5">user thread</span>），让应用程序可以独立决定自己的线程要如何运作。操作系统内核不能看见</div><div class="t m0 x2 h6 y24 ff1 fs2 fc0 sc0 ls0 ws0">它，也不会为它进行调度。就像一般的线程，纤程有自己的寻址空间。但是纤程采取合作式多任</div><div class="t m0 x2 h6 y25 ff1 fs2 fc0 sc0 ls0 ws0">务（<span class="ff5">Cooperative multitasking</span>），而线程采取先占式多任务（<span class="ff5">Pre-emptive multitasking</span>）。应用</div><div class="t m0 x2 h6 y26 ff1 fs2 fc0 sc0 ls0 ws0">程序可以在一个线程环境中创建多个纤程，然后手动执行它。纤程不会被自动执行，必须要由应</div><div class="t m0 x2 h6 y27 ff1 fs2 fc0 sc0 ls0 ws0">用程序自己指定让它执行，或换到下一个纤程。跟线程相比，纤程较不需要操作系统的支持。实</div><div class="t m0 x2 h6 y28 ff1 fs2 fc0 sc0 ls0 ws0">际上也有人任务纤程也属于协程，因为因为这两个并没有一个严格的定义，或者说含义在不同的</div><div class="t m0 x2 h6 y29 ff1 fs2 fc0 sc0 ls0 ws0">人不同的场景下也有所区别，所以不同的人有不同的理解，比如新近<span class="ff5">Java 19</span>终于发布的特性，有</div><div class="t m0 x2 h6 y2a ff1 fs2 fc0 sc0 ls0 ws0">人叫它纤程<span class="ff5">,</span>有人叫它协程。</div><div class="t m0 x2 h6 y2b ff1 fs2 fc0 sc0 ls0 ws0">不管怎么说，<span class="ff5">Rust</span>实现并发的基本单位是线程，虽然也有一些第三方的库，比如<span class="ff5"> PingCAP </span>的黄旭</div><div class="t m0 x2 h6 y2c ff1 fs2 fc0 sc0 ls0 ws0">东实现了<span class="ff5"> S<span class="_ _1"></span>tackful coroutine<span class="ff1">库</span>(<span class="fc1">may</span>)<span class="ff1">和</span> <span class="fc1">coroutine</span><span class="ff1">，甚至有一个</span>RFC(<span class="fc1">RFC 2033: Experimentally add</span></span></div><div class="t m0 x2 h6 y2d ff5 fs2 fc1 sc0 ls0 ws0">coroutines to Rust<span class="fc0">)<span class="ff1">关注它，但是目前</span>Rust<span class="ff1">并发实现主流还是使用线程来实现，包括最近实现的</span></span></div><div class="t m0 x2 h6 y2e ff5 fs2 fc0 sc0 ls0 ws0">async/await<span class="ff1">特性，运行时还是以线程和线程池的方式运行。</span></div><div class="t m0 x2 h6 y2f ff1 fs2 fc0 sc0 ls0 ws0">所以作为<span class="ff5">Rust</span>并发编程的第一章，我们重点还是介绍线程的使用。</div></div><a class="l" href="https://crates.io/crates/may"><div class="d m1" style="border-style:none;position:absolute;left:204.079280px;bottom:162.905701px;width:22.511010px;height:15.757749px;background-color:rgba(255,255,255,0.000001);"></div></a><a class="l" href="https://docs.rs/coroutine/latest/coroutine/"><div class="d m1" style="border-style:none;position:absolute;left:245.349470px;bottom:162.905701px;width:50.274580px;height:15.757749px;background-color:rgba(255,255,255,0.000001);"></div></a><a class="l" href="https://github.com/rust-lang/rust/issues/43122"><div class="d m1" style="border-style:none;position:absolute;left:42.000000px;bottom:144.896912px;width:506.497800px;height:33.766538px;background-color:rgba(255,255,255,0.000001);"></div></a></div><div class="pi" data-data='{"ctm":[1.000000,0.000000,0.000000,1.000000,0.000000,0.000000]}'></div></div>
<div id="pf3" class="pf w0 h0" data-page-no="3"><div class="pc pc3 w0 h0"><img class="bi x0 y0 w3 h1" alt="" src="bg3.png"/><div class="c x0 y30 w2 h8"><div class="t m0 x1 h3 y31 ff1 fs0 fc0 sc0 ls0 ws0">鸟窝<span class="ff2"> - https://github.com/smallnest/concurrency-programming-via-rust</span></div></div><div class="c x0 y32 w2 h9"><div class="t m0 x2 ha y33 ff3 fs3 fc0 sc0 ls0 ws0">创建线程</div><div class="t m0 x2 h6 y34 ff5 fs2 fc0 sc0 ls0 ws0">Rust <span class="ff1">标准库</span><span class="fc1">std::thread</span> crate <span class="ff1">提供了线程相关的函数。正如上面所说，一个</span>Rust<span class="ff1">程序执行的会启动</span></div><div class="t m0 x2 h6 y35 ff1 fs2 fc0 sc0 ls0 ws0">一个进程，这个进程会包含一个或者多个线程，<span class="ff5">Rust</span>中的线程是纯操作的系统的线程，拥有自己</div><div class="t m0 x2 h6 y36 ff1 fs2 fc0 sc0 ls0 ws0">的栈和状态。</div><div class="t m0 x2 h6 y37 ff1 fs2 fc0 sc0 ls0 ws0">线程之间的通讯可以通过<span class="ff5"> <span class="fc1">channel</span></span>，就像<span class="ff5">Go</span>语言推崇的那样，也可以通过一些<span class="fc1">同步原语</span>。这个我</div><div class="t m0 x2 h6 y38 ff1 fs2 fc0 sc0 ls0 ws0">们会在后面的章节中在做介绍。</div></div><div class="c x0 y39 w2 hb"><div class="t m0 x4 hc y3a ff6 fs4 fc2 sc0 ls0 ws0">pub<span class="fc3"> </span>fn<span class="fc3"> <span class="fc4">start_one_thread<span class="fc5">()</span></span> <span class="fc5">{</span> </span></div><div class="t m0 x4 hc y3b ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> handle <span class="fc6">=</span> <span class="_ _2"> </span><span class="fc4">spawn<span class="fc5">(||</span></span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y3c ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;Hello from a thread!&quot;</span>);</span></span> </div><div class="t m0 x4 hc y3d ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">});</span> </div><div class="t m0 x4 hc y3e ff6 fs4 fc3 sc0 ls0 ws0">    handle<span class="fc5">.<span class="fc4">join</span>().<span class="fc4">unwrap</span>();</span> </div><div class="t m0 x4 hc y3f ff6 fs4 fc5 sc0 ls0 ws0">}</div></div><div class="c x0 y32 w2 h9"><div class="t m0 x2 h6 y40 ff1 fs2 fc0 sc0 ls0 ws0">这段代码我们通过<span class="_ _3"> </span><span class="ff6 fs4">thread.spawn<span class="_ _3"> </span></span>在当前线程中启动了一个新的线程，新的线程简单的输出<span class="_ _3"> </span><span class="ff6 fs4">Hello</span></div><div class="t m0 x2 h6 y41 ff6 fs4 fc0 sc0 ls0 ws0">from a thread<span class="_ _3"> </span><span class="ff1 fs2">文本。</span></div><div class="t m0 x2 h6 y42 ff1 fs2 fc0 sc0 ls0 ws0">如果在<span class="_ _3"> </span><span class="ff6 fs4">main<span class="_ _3"> </span></span><span class="ff5"> </span>函数中调用这个<span class="_ _3"> </span><span class="ff6 fs4">start_one_thread<span class="_ _3"> </span></span>函数，控制台中会正常看到这段输出文本，但是</div><div class="t m0 x2 h6 y43 ff1 fs2 fc0 sc0 ls0 ws0">如果注释掉<span class="_ _3"> </span><span class="ff6 fs4">handle.join.unwrap();<span class="_ _3"> </span></span>那一句的话，有可能期望的文本可能不会被输出，原因是当主</div><div class="t m0 x2 h6 y44 ff1 fs2 fc0 sc0 ls0 ws0">程序退出的时候，即使这些新开的线程也会强制退出，所以有时候你需要通过<span class="_ _3"> </span><span class="ff6 fs4">join<span class="_ _3"> </span></span>等待这些线程</div><div class="t m0 x2 h6 y45 ff1 fs2 fc0 sc0 ls0 ws0">完成。如果忽略<span class="_ _3"> </span><span class="ff6 fs4">thread::spawn<span class="_ _3"> </span></span>返回的<span class="_ _3"> </span><span class="ff6 fs4">JoinHandle<span class="_ _3"> </span></span>值，那么这个新建的线程被称之为<span class="_ _3"> </span><span class="ff6 fs4">detached<span class="_ _3"> </span></span>，</div><div class="t m0 x2 h6 y46 ff1 fs2 fc0 sc0 ls0 ws0">通过调用<span class="_ _3"> </span><span class="ff6 fs4">JoinHandle<span class="_ _3"> </span></span>的<span class="_ _3"> </span><span class="ff6 fs4">join<span class="_ _3"> </span></span>方法，调用者就不得不等待线程的完成了。</div><div class="t m0 x2 h6 y47 ff1 fs2 fc0 sc0 ls0 ws0">这段代码我们直接使用<span class="_ _3"> </span><span class="ff6 fs4">handle.join().unwrap()<span class="_ _3"> </span></span><span class="ff5">,</span>事实上<span class="_ _3"> </span><span class="ff6 fs4">jopin()<span class="_ _3"> </span></span>返回的是<span class="_ _3"> </span><span class="ff6 fs4">Result<span class="_ _3"> </span></span>类型，如果线</div><div class="t m0 x2 h6 y48 ff1 fs2 fc0 sc0 ls0 ws0">程<span class="ff5"> panicked</span>了，那么它会返<span class="_ _3"> </span><span class="ff6 fs4">Err<span class="_ _3"> </span></span><span class="ff5">,</span>否则它会返回<span class="_ _3"> </span><span class="ff6 fs4">Ok(_)<span class="_ _3"> </span></span><span class="ff5">,</span>这就有意思了，调用者甚至可以得到线程</div><div class="t m0 x2 h6 y49 ff1 fs2 fc0 sc0 ls0 ws0">最后的返回值：</div></div><div class="c x0 y4a w2 hd"><div class="t m0 x4 hc y4b ff6 fs4 fc2 sc0 ls0 ws0">pub<span class="fc3"> </span>fn<span class="fc3"> <span class="fc4">start_one_thread_result<span class="fc5">()</span></span> <span class="fc5">{</span> </span></div><div class="t m0 x4 hc y4c ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> handle <span class="fc6">=</span> <span class="_ _2"> </span><span class="fc4">spawn<span class="fc5">(||</span></span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y4d ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;Hello from a thread!&quot;</span>);</span></span> </div><div class="t m0 x4 hc y4e ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">200</span> </div><div class="t m0 x4 hc y4f ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">});</span> </div><div class="t m0 x4 hc y50 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">match</span> handle<span class="fc5">.<span class="fc4">join</span>()</span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y51 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc4">Ok<span class="fc5">(</span></span>v<span class="fc5">)</span> <span class="fc6">=&gt;</span> <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;thread result: {}&quot;</span>,</span></span> v<span class="fc5">),</span> <span class="fc9">// 200</span> </div><div class="t m0 x4 hc y52 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc4">Err<span class="fc5">(</span></span>e<span class="fc5">)</span> <span class="fc6">=&gt;</span> <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;error: {:?}&quot;</span>,</span></span> e<span class="fc5">),</span> </div><div class="t m0 x4 hc y53 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">}</span> </div><div class="t m0 x4 hc y54 ff6 fs4 fc5 sc0 ls0 ws0">}</div></div><div class="c x5 y55 w4 he"><div class="t m0 x2 hc y56 ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><div class="c x5 y57 w4 hf"><div class="t m0 x2 hc y58 ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><a class="l" href="https://doc.rust-lang.org/std/thread/"><div class="d m1" style="border-style:none;position:absolute;left:104.280464px;bottom:727.932010px;width:56.277535px;height:15.757750px;background-color:rgba(255,255,255,0.000001);"></div></a><a class="l" href="https://doc.rust-lang.org/std/sync/mpsc/index.html"><div class="d m1" style="border-style:none;position:absolute;left:177.066070px;bottom:661.899660px;width:41.270190px;height:15.757750px;background-color:rgba(255,255,255,0.000001);"></div></a><a class="l" href="https://doc.rust-lang.org/std/sync/index.html"><div class="d m1" style="border-style:none;position:absolute;left:450.199680px;bottom:661.899660px;width:48.023500px;height:15.757750px;background-color:rgba(255,255,255,0.000001);"></div></a></div><div class="pi" data-data='{"ctm":[1.000000,0.000000,0.000000,1.000000,0.000000,0.000000]}'></div></div>
<div id="pf4" class="pf w0 h0" data-page-no="4"><div class="pc pc4 w0 h0"><img class="bi x0 y0 w3 h7" alt="" src="bg4.png"/><div class="c x0 y59 w2 h2"><div class="t m0 x1 h3 y2 ff1 fs0 fc0 sc0 ls0 ws0">鸟窝<span class="ff2"> - https://github.com/smallnest/concurrency-programming-via-rust</span></div></div><div class="c x0 y3 w2 h4"><div class="t m0 x2 h6 y5a ff1 fs2 fc0 sc0 ls0 ws0">下面这段代码是启动了多个线程：</div></div><div class="c x0 y5b w2 h10"><div class="t m0 x4 hc y5c ff6 fs4 fc2 sc0 ls0 ws0">pub<span class="fc3"> </span>fn<span class="fc3"> <span class="fc4">start_two_threads<span class="fc5">()</span></span> <span class="fc5">{</span> </span></div><div class="t m0 x4 hc y5d ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> handle1 <span class="fc6">=</span> <span class="_ _2"> </span><span class="fc4">spawn<span class="fc5">(||</span></span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y5e ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;Hello from a thread1!&quot;</span>);</span></span></div><div class="t m0 x4 hc y5f ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">});</span> </div><div class="t m0 x4 hc y60 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> handle2 <span class="fc6">=</span> <span class="_ _2"> </span><span class="fc4">spawn<span class="fc5">(||</span></span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y61 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;Hello from a thread2!&quot;</span>);</span></span></div><div class="t m0 x4 hc y62 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">});</span> </div><div class="t m0 x4 hc y63 ff6 fs4 fc3 sc0 ls0 ws0">    handle1<span class="fc5">.<span class="fc4">join</span>().<span class="fc4">unwrap</span>();</span> </div><div class="t m0 x4 hc y64 ff6 fs4 fc3 sc0 ls0 ws0">    handle2<span class="fc5">.<span class="fc4">join</span>().<span class="fc4">unwrap</span>();</span> </div><div class="t m0 x4 hc y65 ff6 fs4 fc5 sc0 ls0 ws0">}</div></div><div class="c x0 y3 w2 h4"><div class="t m0 x2 h6 y66 ff1 fs2 fc0 sc0 ls0 ws0">但是如果启动<span class="ff5">N</span>个线程呢？可以使用一个<span class="ff5">V<span class="_ _4"></span>ector<span class="ff1">保存线程的</span>handle:</span></div></div><div class="c x0 y67 w2 h11"><div class="t m0 x4 hc y68 ff6 fs4 fc2 sc0 ls0 ws0">pub<span class="fc3"> </span>fn<span class="fc3"> <span class="fc4">start_n_threads<span class="fc5">()</span></span> <span class="fc5">{</span> </span></div><div class="t m0 x4 hc y69 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">const</span> <span class="fc4">N<span class="fc5">:</span></span> <span class="fc2">isize</span> <span class="fc6">=</span> <span class="fc7">10<span class="fc5">;</span></span> </div><div class="t m0 x4 hc y6a ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> handles<span class="fc5">:</span> <span class="fc4">Vec<span class="fc6">&lt;</span></span>_<span class="fc6">&gt;</span> <span class="fc6">=</span> <span class="fc5">(<span class="fc7">0</span>..<span class="fc4">N</span>)</span> </div><div class="t m0 x4 hc y6b ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc5">.<span class="fc4">map</span>(|</span>i<span class="fc5">|</span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y6c ff6 fs4 fc3 sc0 ls0 ws0">            <span class="_ _2"> </span><span class="fc4">spawn<span class="fc5">(<span class="fc2">move</span></span></span> <span class="fc5">||</span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y6d ff6 fs4 fc3 sc0 ls0 ws0">                <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;Hello from a thread{}!&quot;</span>,</span></span> i<span class="fc5">);</span> </div><div class="t m0 x4 hc y6e ff6 fs4 fc3 sc0 ls0 ws0">            <span class="fc5">})</span> </div><div class="t m0 x4 hc y6f ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc5">})</span> </div><div class="t m0 x4 hc y70 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc5">.<span class="fc4">collect</span>();</span> </div><div class="t m0 x4 hc y71 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc9">// handles.into_iter().for_each(|h| h.join().unwrap());</span> </div><div class="t m0 x4 hc y72 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">for</span> handle <span class="fc2">in</span> handles <span class="fc5">{</span> </div><div class="t m0 x4 hc y73 ff6 fs4 fc3 sc0 ls0 ws0">        handle<span class="fc5">.<span class="fc4">join</span>().<span class="fc4">unwrap</span>();</span> </div><div class="t m0 x4 hc y74 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">}</span> </div><div class="t m0 x4 hc y75 ff6 fs4 fc5 sc0 ls0 ws0">}</div></div><div class="c x0 y3 w2 h4"><div class="t m0 x2 h12 y76 ff4 fs3 fc0 sc0 ls0 ws0">Thread Builder</div><div class="t m0 x2 h6 y77 ff1 fs2 fc0 sc0 ls0 ws0">通过<span class="ff5 fc1">Builder</span>你可以对线程的初始状态进行更多的控制，比如设置线程的名称、栈大大小等等。</div></div><div class="c x6 y78 w5 h13"><div class="t m0 x2 hc y79 ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><div class="c x6 y7a w5 h13"><div class="t m0 x2 hc y7b ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><div class="c x7 y7c w5 h13"><div class="t m0 x2 hc y7d ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><a class="l" href="https://doc.rust-lang.org/std/thread/struct.Builder.html"><div class="d m1" style="border-style:none;position:absolute;left:66.011749px;bottom:190.669190px;width:36.767983px;height:15.757750px;background-color:rgba(255,255,255,0.000001);"></div></a></div><div class="pi" data-data='{"ctm":[1.000000,0.000000,0.000000,1.000000,0.000000,0.000000]}'></div></div>
<div id="pf5" class="pf w0 h0" data-page-no="5"><div class="pc pc5 w0 h0"><img class="bi x0 y0 w3 h7" alt="" src="bg5.png"/><div class="c x0 y59 w2 h2"><div class="t m0 x1 h3 y2 ff1 fs0 fc0 sc0 ls0 ws0">鸟窝<span class="ff2"> - https://github.com/smallnest/concurrency-programming-via-rust</span></div></div><div class="c x0 y7e w2 h14"><div class="t m0 x4 hc y7f ff6 fs4 fc2 sc0 ls0 ws0">pub<span class="fc3"> </span>fn<span class="fc3"> <span class="fc4">start_one_thread_by_builder<span class="fc5">()</span></span> <span class="fc5">{</span> </span></div><div class="t m0 x4 hc y80 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> builder <span class="fc6">=</span> <span class="_ _2"> </span><span class="fc4">Builder<span class="fc5">::</span>new<span class="fc5">()</span></span></div><div class="t m0 x4 hc y81 ff6 fs4 fc3 sc0 ls0 ws0">                              <span class="fc5">.<span class="fc4">name</span>(<span class="fc8">&quot;foo&quot;</span>.<span class="fc4">into</span>())</span> <span class="fc9">// set thread name</span> </div><div class="t m0 x4 hc y82 ff6 fs4 fc3 sc0 ls0 ws0">                              <span class="fc5">.<span class="fc4">stack_size</span>(<span class="fc7">32</span></span> <span class="fc6">*</span> <span class="fc7">1024<span class="fc5">);</span></span> <span class="fc9">// set stack size</span> </div><div class="t m0 x4 hc y83 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> handler <span class="fc6">=</span> builder<span class="fc5">.<span class="fc4">spawn</span>(||</span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y84 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;Hello from a thread!&quot;</span>);</span></span> </div><div class="t m0 x4 hc y85 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">}).<span class="fc4">unwrap</span>();</span> </div><div class="t m0 x4 hc y86 ff6 fs4 fc3 sc0 ls0 ws0">    handler<span class="fc5">.<span class="fc4">join</span>().<span class="fc4">unwrap</span>();</span> </div><div class="t m0 x4 hc y87 ff6 fs4 fc5 sc0 ls0 ws0">}</div></div><div class="c x0 y3 w2 h4"><div class="t m0 x2 h6 y88 ff1 fs2 fc0 sc0 ls0 ws0">它提供了<span class="_ _3"> </span><span class="ff6 fs4">spawn<span class="_ _3"> </span></span>开启一个线程，同时还提供了<span class="_ _3"> </span><span class="ff6 fs4">spawn_scoped<span class="_ _3"> </span></span>开启<span class="ff5">scoped thread (</span>下面会讲<span class="ff5">)</span>，一个</div><div class="t m0 x2 h6 y89 ff1 fs2 fc0 sc0 ls0 ws0">实验性的方法<span class="_ _3"> </span><span class="ff6 fs4">spawn_unchecked<span class="_ _3"> </span></span><span class="ff5">,</span>提供更宽松的声明周期的绑定，调用者要确保引用的对象丢弃之</div><div class="t m0 x2 h6 y8a ff1 fs2 fc0 sc0 ls0 ws0">前线程的<span class="_ _3"> </span><span class="ff6 fs4">join<span class="_ _3"> </span></span>一定要被调用，或者使用<span class="ff5">``static`</span>声明周期，因为是实验性的方法，我们不做过多</div><div class="t m0 x2 h6 y8b ff1 fs2 fc0 sc0 ls0 ws0">介绍，一个简单的例子如下<span class="ff5">:</span></div></div><div class="c x0 y8c w2 h15"><div class="t m0 x4 hc y8d ff6 fs4 fc8 sc0 ls0 ws0">#![feature(thread_spawn_unchecked)]<span class="fc3"> </span></div><div class="t m0 x4 hc y8e ff6 fs4 fc2 sc0 ls0 ws0">use<span class="fc3"> <span class="_ _5"> </span>thread<span class="fc5">;</span> </span></div><div class="t m0 x4 hc y8f ff6 fs4 fc2 sc0 ls0 ws0">let<span class="fc3"> builder <span class="fc6">=</span> <span class="_ _2"> </span><span class="fc4">Builder<span class="fc5">::</span>new<span class="fc5">();</span></span> </span></div><div class="t m0 x4 hc y90 ff6 fs4 fc2 sc0 ls0 ws0">let<span class="fc3"> x <span class="fc6">=</span> <span class="fc7">1<span class="fc5">;</span></span> </span></div><div class="t m0 x4 hc y91 ff6 fs4 fc2 sc0 ls0 ws0">let<span class="fc3"> thread_x <span class="fc6">=</span> <span class="fc6">&amp;</span>x<span class="fc5">;</span> </span></div><div class="t m0 x4 hc y92 ff6 fs4 fc2 sc0 ls0 ws0">let<span class="fc3"> handler <span class="fc6">=</span> </span>unsafe<span class="fc3"> <span class="fc5">{</span> </span></div><div class="t m0 x4 hc y93 ff6 fs4 fc3 sc0 ls0 ws0">    builder<span class="fc5">.<span class="fc4">spawn_unchecked</span>(<span class="fc2">move</span></span> <span class="fc5">||</span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y94 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;x = {}&quot;</span>,</span></span> <span class="fc6">*</span>thread_x<span class="fc5">);</span> </div><div class="t m0 x4 hc y95 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">}).<span class="fc4">unwrap</span>()</span> </div><div class="t m0 x4 hc y96 ff6 fs4 fc5 sc0 ls0 ws0">};<span class="fc3"> </span></div><div class="t m0 x4 hc y97 ff6 fs4 fc9 sc0 ls0 ws0">// caller has to ensure `join()` is called, otherwise<span class="fc3"> </span></div><div class="t m0 x4 hc y98 ff6 fs4 fc9 sc0 ls0 ws0">// it is possible to access freed memory if `x` gets<span class="fc3"> </span></div><div class="t m0 x4 hc y99 ff6 fs4 fc9 sc0 ls0 ws0">// dropped before the thread closure is executed!<span class="fc3"> </span></div><div class="t m0 x4 hc y9a ff6 fs4 fc3 sc0 ls0 ws0">handler<span class="fc5">.<span class="fc4">join</span>().<span class="fc4">unwrap</span>();</span></div></div><div class="c x0 y3 w2 h4"><div class="t m0 x2 ha y9b ff3 fs3 fc0 sc0 ls0 ws0">当前的线程</div><div class="t m0 x2 h6 y9c ff1 fs2 fc0 sc0 ls0 ws0">因为线程是操作系统最小的调度和运算单元，所以一段代码的执行隶属于某个线程。如何获得当</div><div class="t m0 x2 h6 y9d ff1 fs2 fc0 sc0 ls0 ws0">前的线程呢？通过<span class="_ _3"> </span><span class="ff6 fs4">thread::current()<span class="_ _3"> </span></span>就可以获得，它会返回一个<span class="ff5 fc1">Thread</span>对象，你可以通过它获</div><div class="t m0 x2 h6 y9e ff1 fs2 fc0 sc0 ls0 ws0">得线程的<span class="ff5">ID</span>和<span class="ff5">name:</span></div></div><div class="c x6 y9f w5 h13"><div class="t m0 x2 hc ya0 ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><div class="c x8 ya1 w6 h13"><div class="t m0 x2 hc ya2 ff6 fs4 fc3 sc0 ls0 ws0">std<span class="fc5">::</span></div></div><div class="c x9 ya3 w7 h13"><div class="t m0 x2 hc ya4 ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><a class="l" href="https://doc.rust-lang.org/stable/std/thread/struct.Thread.html"><div class="d m1" style="border-style:none;position:absolute;left:384.917760px;bottom:134.391785px;width:36.767970px;height:15.757751px;background-color:rgba(255,255,255,0.000001);"></div></a></div><div class="pi" data-data='{"ctm":[1.000000,0.000000,0.000000,1.000000,0.000000,0.000000]}'></div></div>
<div id="pf6" class="pf w0 h0" data-page-no="6"><div class="pc pc6 w0 h0"><img class="bi x0 y0 w3 h7" alt="" src="bg6.png"/><div class="c x0 ya5 w2 h2"><div class="t m0 x1 h3 y2 ff1 fs0 fc0 sc0 ls0 ws0">鸟窝<span class="ff2"> - https://github.com/smallnest/concurrency-programming-via-rust</span></div></div><div class="c x0 ya6 w2 h16"><div class="t m0 x4 hc ya7 ff6 fs4 fc2 sc0 ls0 ws0">pub<span class="fc3"> </span>fn<span class="fc3"> <span class="fc4">current_thread<span class="fc5">()</span></span> <span class="fc5">{</span> </span></div><div class="t m0 x4 hc ya8 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> current_thread <span class="fc6">=</span> <span class="_ _2"> </span><span class="fc4">current<span class="fc5">();</span></span> </div><div class="t m0 x4 hc ya9 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;current thread: {:?},{:?}&quot;</span>,</span></span> current_thread<span class="fc5">.<span class="fc4">id</span>(),</span> current_thread<span class="fc5">.<span class="fc4">name</span>());</span> </div><div class="t m0 x4 hc yaa ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> builder <span class="fc6">=</span> <span class="_ _2"> </span><span class="fc4">Builder<span class="fc5">::</span>new<span class="fc5">()</span></span></div><div class="t m0 x4 hc yab ff6 fs4 fc3 sc0 ls0 ws0">                              <span class="fc5">.<span class="fc4">name</span>(<span class="fc8">&quot;foo&quot;</span>.<span class="fc4">into</span>())</span> <span class="fc9">// set thread name</span> </div><div class="t m0 x4 hc yac ff6 fs4 fc3 sc0 ls0 ws0">                              <span class="fc5">.<span class="fc4">stack_size</span>(<span class="fc7">32</span></span> <span class="fc6">*</span> <span class="fc7">1024<span class="fc5">);</span></span> <span class="fc9">// set stack size</span> </div><div class="t m0 x4 hc yad ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> handler <span class="fc6">=</span> builder<span class="fc5">.<span class="fc4">spawn</span>(||</span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y3a ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc2">let</span> current_thread <span class="fc6">=</span> <span class="_ _2"> </span><span class="fc4">current<span class="fc5">();</span></span> </div><div class="t m0 x4 hc y3b ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;child thread: {:?},{:?}&quot;</span>,</span></span> current_thread<span class="fc5">.<span class="fc4">id</span>(),</span> </div><div class="t m0 x4 hc y3c ff6 fs4 fc3 sc0 ls0 ws0">current_thread<span class="fc5">.<span class="fc4">name</span>());</span> </div><div class="t m0 x4 hc y3d ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">}).<span class="fc4">unwrap</span>();</span> </div><div class="t m0 x4 hc y3e ff6 fs4 fc3 sc0 ls0 ws0">    handler<span class="fc5">.<span class="fc4">join</span>().<span class="fc4">unwrap</span>();</span> </div><div class="t m0 x4 hc y3f ff6 fs4 fc5 sc0 ls0 ws0">}</div></div><div class="c x0 yae w2 h17"><div class="t m0 x2 h6 yaf ff1 fs2 fc0 sc0 ls0 ws0">甚至，你还可以通过它的<span class="_ _3"> </span><span class="ff6 fs4">unpark<span class="_ _3"> </span></span>方法，唤醒这个被阻塞<span class="ff5">(parked)</span>的线程<span class="ff5">:</span></div></div><div class="c x0 yb0 w2 h18"><div class="t m0 x4 hc yb1 ff6 fs4 fc3 sc0 ls0 ws0">use std<span class="fc5">::</span>thread<span class="fc5">;</span> </div><div class="t m0 x4 hc yb2 ff6 fs4 fc3 sc0 ls0 ws0">use std<span class="fc5">::</span>time<span class="fc5">::</span>Duration<span class="fc5">;</span> </div><div class="t m0 x4 hc yb3 ff6 fs4 fc3 sc0 ls0 ws0">let parked_thread <span class="fc6">=</span> thread<span class="fc5">::</span>Builder<span class="fc5">::<span class="fc4">new</span>()</span> </div><div class="t m0 x4 hc yb4 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">.<span class="fc4">spawn</span>(<span class="fc6">||</span></span> <span class="fc5">{</span> </div><div class="t m0 x4 hc yb5 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc8">println<span class="fc6">!<span class="fc5">(</span></span>&quot;Parking thread&quot;<span class="fc5">);</span></span> </div><div class="t m0 x4 hc yb6 ff6 fs4 fc3 sc0 ls0 ws0">        thread<span class="fc5">::<span class="fc4">park</span>();</span> </div><div class="t m0 x4 hc yb7 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc8">println<span class="fc6">!<span class="fc5">(</span></span>&quot;Thread unparked&quot;<span class="fc5">);</span></span> </div><div class="t m0 x4 hc yb8 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">})</span> </div><div class="t m0 x4 hc yb9 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">.<span class="fc4">unwrap</span>();</span> </div><div class="t m0 x4 hc yba ff6 fs4 fc9 sc0 ls0 ws0">// Let some time pass for the thread to be spawned.<span class="fc3"> </span></div><div class="t m0 x4 hc ybb ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::<span class="fc4">sleep</span>(</span>Duration<span class="fc5">::<span class="fc4">from_millis</span>(<span class="fc7">10</span>));</span> </div><div class="t m0 x4 hc ybc ff6 fs4 fc8 sc0 ls0 ws0">println<span class="fc6">!<span class="fc5">(</span></span>&quot;Unpark the thread&quot;<span class="fc5">);<span class="fc3"> </span></span></div><div class="t m0 x4 hc ybd ff6 fs4 fc3 sc0 ls0 ws0">parked_thread<span class="fc5">.<span class="fc4">thread</span>().<span class="fc4">unpark</span>();</span> </div><div class="t m0 x4 hc ybe ff6 fs4 fc3 sc0 ls0 ws0">parked_thread<span class="fc5">.<span class="fc4">join</span>().<span class="fc4">unwrap</span>();</span></div></div><div class="c x0 yae w2 h17"><div class="t m0 xa h6 ybf ff6 fs4 fc0 sc0 ls0 ws0">park<span class="_ _3"> </span><span class="ff1 fs2">和<span class="_ _3"> </span></span>unpark<span class="_ _3"> </span><span class="ff1 fs2">用来阻塞和欢迎线程的方法，利用它们可以有效的利用<span class="ff5">CPU,</span>让暂时不满足条件的</span></div><div class="t m0 x2 h6 yc0 ff1 fs2 fc0 sc0 ls0 ws0">线程暂时不可执行。</div><div class="t m0 x2 ha yc1 ff3 fs3 fc0 sc0 ls0 ws0">并发数和当前线程数</div></div><div class="c xb y9f w5 h13"><div class="t m0 x2 hc yc2 ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><div class="c x6 yc3 w5 h13"><div class="t m0 x2 hc yc4 ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><div class="c xc yc5 w5 h13"><div class="t m0 x2 hc yc6 ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div></div><div class="pi" data-data='{"ctm":[1.000000,0.000000,0.000000,1.000000,0.000000,0.000000]}'></div></div>
<div id="pf7" class="pf w0 h0" data-page-no="7"><div class="pc pc7 w0 h0"><img class="bi x0 y0 w3 h1" alt="" src="bg7.png"/><div class="c x0 yc7 w2 h2"><div class="t m0 x1 h3 y2 ff1 fs0 fc0 sc0 ls0 ws0">鸟窝<span class="ff2"> - https://github.com/smallnest/concurrency-programming-via-rust</span></div></div><div class="c x0 yc8 w2 h19"><div class="t m0 x2 h6 yc9 ff1 fs2 fc0 sc0 ls0 ws0">并发能力是一种资源，一个机器能够提供并发的能力值，这个数值一般等价于计算机拥有的<span class="ff5">CPU</span></div><div class="t m0 x2 h6 yca ff1 fs2 fc0 sc0 ls0 ws0">数（逻辑的核数），但是在虚机和容器的环境下，程序可以使用的<span class="ff5">CPU</span>核数可能受到限制。</div><div class="t m0 x2 h6 ycb ff1 fs2 fc0 sc0 ls0 ws0">你可以通过<span class="_ _3"> </span><span class="ff6 fs4">available_parallelism<span class="_ _3"> </span></span>获取当前的并发数：</div></div><div class="c x0 ycc w2 h1a"><div class="t m0 x4 hc y4f ff6 fs4 fc2 sc0 ls0 ws0">use<span class="fc3"> <span class="_ _5"> </span><span class="fc5">{</span>io<span class="fc5">,</span> thread<span class="fc5">};</span> </span></div><div class="t m0 x4 hc y50 ff6 fs4 fc2 sc0 ls0 ws0">fn<span class="fc3"> <span class="fc4">main<span class="fc5">()</span></span> <span class="fc5">-&gt;</span> <span class="_ _6"> </span><span class="fc4">Result<span class="fc6">&lt;<span class="fc5">()</span>&gt;</span></span> <span class="fc5">{</span> </span></div><div class="t m0 x4 hc y51 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> count <span class="fc6">=</span> <span class="_ _2"> </span><span class="fc4">available_parallelism<span class="fc5">()<span class="fc6">?</span>.</span>get<span class="fc5">();</span></span> </div><div class="t m0 x4 hc y52 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc7">assert!<span class="fc5">(</span></span>count <span class="fc6">&gt;=</span> <span class="fc7">1_usize<span class="fc5">);</span></span> </div><div class="t m0 x4 hc y53 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc4">Ok<span class="fc5">(())</span></span> </div><div class="t m0 x4 hc y54 ff6 fs4 fc5 sc0 ls0 ws0">}</div></div><div class="c x0 yc8 w2 h19"><div class="t m0 x2 h6 ycd ff5 fs2 fc1 sc0 ls0 ws0">affinity <span class="fc0">(<span class="ff1">不支持</span>MacOS) crate <span class="ff1">可以提供当前的</span>CPU<span class="ff1">核数</span>:</span></div></div><div class="c x0 yce w2 h1b"><div class="t m0 x4 hc ycf ff6 fs4 fc2 sc0 ls0 ws0">let<span class="fc3"> cores<span class="fc5">:</span> <span class="fc4">Vec<span class="fc6">&lt;</span></span></span>usize<span class="fc6">&gt;<span class="fc3"> </span>=<span class="fc3"> <span class="fc5">(<span class="fc7">0</span>..<span class="fc4">get_core_num</span>()).<span class="fc4">step_by</span>(<span class="fc7">2</span>).<span class="fc4">collect</span>();</span> </span></span></div><div class="t m0 x4 hc yd0 ff6 fs4 fc7 sc0 ls0 ws0">println!<span class="fc5">(<span class="fc8">&quot;cores : {:?}&quot;</span>,<span class="fc3"> <span class="fc6">&amp;</span>cores</span>);</span></div></div><div class="c x0 yc8 w2 h19"><div class="t m0 x2 h6 yd1 ff1 fs2 fc0 sc0 ls0 ws0">更多的，我们使用<span class="ff5 fc1">num_cpus</span>获取<span class="ff5">CPU</span>的核数（逻辑核）：</div></div><div class="c x0 yd2 w2 h1c"><div class="t m0 x4 hc yd3 ff6 fs4 fc2 sc0 ls0 ws0">use<span class="fc3"> num_cpus<span class="fc5">;</span> </span></div><div class="t m0 x4 hc yd4 ff6 fs4 fc9 sc0 ls0 ws0">// count logical cores this process could try to use<span class="fc3"> </span></div><div class="t m0 x4 hc yd5 ff6 fs4 fc2 sc0 ls0 ws0">let<span class="fc3"> num <span class="fc6">=</span> <span class="_ _7"> </span><span class="fc4">get<span class="fc5">();</span></span></span></div></div><div class="c x0 yc8 w2 h19"><div class="t m0 x2 h6 yd6 ff1 fs2 fc0 sc0 ls0 ws0">如果想获得当前进程的线程数，比如在一些性能监控收集指标的时候，你可以使用<span class="ff5 fc1">num_threads</span></div><div class="t m0 x2 h6 yd7 ff5 fs2 fc0 sc0 ls0 ws0">crate, <span class="ff1">实际测试</span>num_threads <span class="ff1">不支持</span>windows<span class="ff1">，所以你可以使用</span><span class="fc1">thread-amount</span><span class="ff1">代替。</span></div><div class="t m0 x2 h6 yd8 ff5 fs2 fc0 sc0 ls0 ws0">(Rust<span class="ff1">生态圈就是这样，有很多功能相同或者类似的</span>crate,<span class="ff1">你可能需要花费时间进行评估和比较</span>,<span class="ff1">不</span></div><div class="t m0 x2 h6 yd9 ff1 fs2 fc0 sc0 ls0 ws0">像<span class="ff5">Go</span>生态圈，优选标准库的包，如果没有，生态圈中一般会有一个或者几个高标准的大家公认的</div><div class="t m0 x2 h6 yda ff1 fs2 fc0 sc0 ls0 ws0">库可以使用。相对而言，<span class="ff5">Rust</span>生态圈就比较分裂<span class="ff5">,</span>这一点在选择异步运行时或者网络库的时候感受</div><div class="t m0 x2 h6 ydb ff1 fs2 fc0 sc0 ls0 ws0">相当明显。<span class="ff5">)</span></div></div><div class="c x8 ydc w6 h13"><div class="t m0 x2 hc ydd ff6 fs4 fc3 sc0 ls0 ws0">std<span class="fc5">::</span></div></div><div class="c xd yde w8 h13"><div class="t m0 x2 hc ydf ff6 fs4 fc3 sc0 ls0 ws0">io<span class="fc5">::</span></div></div><div class="c xe ye0 w7 h13"><div class="t m0 x2 hc ye1 ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><div class="c xf ye2 w9 h13"><div class="t m0 x2 hc ye3 ff6 fs4 fc3 sc0 ls0 ws0">num_cpus<span class="fc5">::</span></div></div><a class="l" href="https://crates.io/crates/affinity"><div class="d m1" style="border-style:none;position:absolute;left:42.000000px;bottom:554.596800px;width:39.769455px;height:15.758000px;background-color:rgba(255,255,255,0.000001);"></div></a><a class="l" href="https://crates.io/crates/num_cpus"><div class="d m1" style="border-style:none;position:absolute;left:138.046982px;bottom:460.050900px;width:53.276058px;height:15.757510px;background-color:rgba(255,255,255,0.000001);"></div></a><a class="l" href="https://docs.rs/num_threads/0.1.6/num_threads/fn.num_threads.html"><div class="d m1" style="border-style:none;position:absolute;left:474.211430px;bottom:336.990450px;width:68.283440px;height:15.757960px;background-color:rgba(255,255,255,0.000001);"></div></a><a class="l" href="https://crates.io/crates/thread-amount"><div class="d m1" style="border-style:none;position:absolute;left:372.161500px;bottom:318.981510px;width:80.289310px;height:15.757990px;background-color:rgba(255,255,255,0.000001);"></div></a></div><div class="pi" data-data='{"ctm":[1.000000,0.000000,0.000000,1.000000,0.000000,0.000000]}'></div></div>
<div id="pf8" class="pf w0 h0" data-page-no="8"><div class="pc pc8 w0 h0"><img class="bi x0 y0 w3 h1" alt="" src="bg8.png"/><div class="c x0 y59 w2 h2"><div class="t m0 x1 h3 y2 ff1 fs0 fc0 sc0 ls0 ws0">鸟窝<span class="ff2"> - https://github.com/smallnest/concurrency-programming-via-rust</span></div></div><div class="c x0 ye4 w2 h1d"><div class="t m0 x4 hc ye5 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> count <span class="fc6">=</span> <span class="_ _2"> </span><span class="fc4">available_parallelism<span class="fc5">().</span>unwrap<span class="fc5">().</span>get<span class="fc5">();</span></span> </div><div class="t m0 x4 hc ye6 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;available_parallelism: {}&quot;</span>,</span></span> count<span class="fc5">);</span> </div><div class="t m0 x4 hc ye7 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">if</span> <span class="fc2">let</span> <span class="fc4">Some<span class="fc5">(</span></span>count<span class="fc5">)</span> <span class="fc6">=</span> <span class="_ _8"> </span><span class="fc4">num_threads<span class="fc5">()</span></span> <span class="fc5">{</span> </div><div class="t m0 x4 hc ye8 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;num_threads: {}&quot;</span>,</span></span> count<span class="fc5">);</span> </div><div class="t m0 x4 hc ye9 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">}</span> <span class="fc2">else</span> <span class="fc5">{</span> </div><div class="t m0 x4 hc yea ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;num_threads: not supported&quot;</span>);</span></span> </div><div class="t m0 x4 hc yeb ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">}</span> </div><div class="t m0 x4 hc yec ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> count <span class="fc6">=</span> <span class="_ _9"> </span><span class="fc4">thread_amount<span class="fc5">();</span></span> </div><div class="t m0 x4 hc yed ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;thread_amount: {}&quot;</span>,</span></span> count<span class="fc5">.<span class="fc4">unwrap</span>());</span> </div><div class="t m0 x4 hc yee ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> count <span class="fc6">=</span> <span class="_ _7"> </span><span class="fc4">get<span class="fc5">();</span></span> </div><div class="t m0 x4 hc yef ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;num_cpus: {}&quot;</span>,</span></span> count<span class="fc5">);{}</span>&quot;<span class="fc5">,</span> count<span class="fc5">);</span></div></div><div class="c x0 yf0 w2 h1e"><div class="t m0 x2 ha yf1 ff4 fs3 fc0 sc0 ls0 ws0">sleep <span class="ff3">和</span> park</div><div class="t m0 x2 h6 yf2 ff1 fs2 fc0 sc0 ls0 ws0">有时候我们我们需要将当前的业务暂停一段时间，可能是某些条件不满足，比如实现<span class="ff5">spinlock,</span>或</div><div class="t m0 x2 h6 yf3 ff1 fs2 fc0 sc0 ls0 ws0">者是想定时的执行某些业务，如<span class="ff5">cron</span>类的程序，这个时候我们可以调用<span class="_ _3"> </span><span class="ff6 fs4">thread::sleep<span class="_ _3"> </span></span>函数：</div></div><div class="c x0 yf4 w2 h1f"><div class="t m0 x4 hc yf5 ff6 fs4 fc2 sc0 ls0 ws0">pub<span class="fc3"> </span>fn<span class="fc3"> <span class="fc4">start_thread_with_sleep<span class="fc5">()</span></span> <span class="fc5">{</span> </span></div><div class="t m0 x4 hc yf6 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> handle1 <span class="fc6">=</span> <span class="_ _2"> </span><span class="fc4">spawn<span class="fc5">(||</span></span> <span class="fc5">{</span> </div><div class="t m0 x4 hc yf7 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="_ _2"> </span><span class="fc4">sleep<span class="fc5">(</span>Duration<span class="fc5">::</span>from_millis<span class="fc5">(<span class="fc7">2000</span>));</span></span> </div><div class="t m0 x4 hc yf8 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;Hello from a thread3!&quot;</span>);</span></span></div><div class="t m0 x4 hc yf9 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">});</span> </div><div class="t m0 x4 hc yfa ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> handle2 <span class="fc6">=</span> <span class="_ _2"> </span><span class="fc4">spawn<span class="fc5">(||</span></span> <span class="fc5">{</span> </div><div class="t m0 x4 hc yfb ff6 fs4 fc3 sc0 ls0 ws0">        <span class="_ _2"> </span><span class="fc4">sleep<span class="fc5">(</span>Duration<span class="fc5">::</span>from_millis<span class="fc5">(<span class="fc7">1000</span>));</span></span> </div><div class="t m0 x4 hc yfc ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;Hello from a thread4!&quot;</span>);</span></span></div><div class="t m0 x4 hc yfd ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">});</span> </div><div class="t m0 x4 hc yfe ff6 fs4 fc3 sc0 ls0 ws0">    handle1<span class="fc5">.<span class="fc4">join</span>().<span class="fc4">unwrap</span>();</span> </div><div class="t m0 x4 hc yff ff6 fs4 fc3 sc0 ls0 ws0">    handle2<span class="fc5">.<span class="fc4">join</span>().<span class="fc4">unwrap</span>();</span> </div><div class="t m0 x4 hc y100 ff6 fs4 fc5 sc0 ls0 ws0">}</div></div><div class="c x0 yf0 w2 h1e"><div class="t m0 x2 h6 y101 ff1 fs2 fc0 sc0 ls0 ws0">它至少保证当前线程<span class="ff5">sleep</span>指定的时间。因为它会阻塞当前的线程，所以不要在异步的代码中调用</div><div class="t m0 x2 h6 y102 ff1 fs2 fc0 sc0 ls0 ws0">它。如果时间设置为<span class="ff5">0,</span>不同的平台处理是不一样的，<span class="ff5">Unix</span>类的平台会立即返回，不会调用</div><div class="t m0 xa h6 y103 ff6 fs4 fc0 sc0 ls0 ws0">nanosleep<span class="_ _3"> </span><span class="ff1 fs2">系统调用，而<span class="ff5">Windows</span>平台总是会调用底层的<span class="_ _3"> </span></span>Sleep<span class="_ _3"> </span><span class="ff1 fs2">系统调用。如果你只是想让渡出</span></div><div class="t m0 x2 h6 y104 ff1 fs2 fc0 sc0 ls0 ws0">时间片，你不用设置时间为<span class="ff5">0</span>，而是调用<span class="_ _3"> </span><span class="ff6 fs4">yield_now<span class="_ _3"> </span></span>函数即可：</div></div><div class="c xe y105 w7 h13"><div class="t m0 x2 hc y106 ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><div class="c xb yc3 wa h13"><div class="t m0 x2 hc y107 ff6 fs4 fc3 sc0 ls0 ws0">num_threads<span class="fc5">::</span></div></div><div class="c xe y108 wb h13"><div class="t m0 x2 hc y109 ff6 fs4 fc3 sc0 ls0 ws0">thread_amount<span class="fc5">::</span></div></div><div class="c xe y10a wc h13"><div class="t m0 x2 hc y10b ff6 fs4 fc3 sc0 ls0 ws0">num_cpus<span class="fc5">::</span></div></div><div class="c x6 y10c w5 he"><div class="t m0 x2 hc y10d ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><div class="c x10 y10e w5 hf"><div class="t m0 x2 hc y10f ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><div class="c x6 y110 w5 he"><div class="t m0 x2 hc y111 ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><div class="c x10 y112 w5 hf"><div class="t m0 x2 hc y113 ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div></div><div class="pi" data-data='{"ctm":[1.000000,0.000000,0.000000,1.000000,0.000000,0.000000]}'></div></div>
<div id="pf9" class="pf w0 h0" data-page-no="9"><div class="pc pc9 w0 h0"><img class="bi x0 y0 w3 h1" alt="" src="bg9.png"/><div class="c x0 yf0 w2 h20"><div class="t m0 x1 h3 y114 ff1 fs0 fc0 sc0 ls0 ws0">鸟窝<span class="ff2"> - https://github.com/smallnest/concurrency-programming-via-rust</span></div></div><div class="c x0 y115 w2 h21"><div class="t m0 x4 hc y116 ff6 fs4 fc2 sc0 ls0 ws0">pub<span class="fc3"> </span>fn<span class="fc3"> <span class="fc4">start_thread_with_yield_now<span class="fc5">()</span></span> <span class="fc5">{</span> </span></div><div class="t m0 x4 hc y117 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> handle1 <span class="fc6">=</span> <span class="_ _2"> </span><span class="fc4">spawn<span class="fc5">(||</span></span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y118 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="_ _2"> </span><span class="fc4">yield_now<span class="fc5">();</span></span> </div><div class="t m0 x4 hc y119 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;yield_now!&quot;</span>);</span></span> </div><div class="t m0 x4 hc y11a ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">});</span> </div><div class="t m0 x4 hc y11b ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> handle2 <span class="fc6">=</span> <span class="_ _2"> </span><span class="fc4">spawn<span class="fc5">(||</span></span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y11c ff6 fs4 fc3 sc0 ls0 ws0">        <span class="_ _2"> </span><span class="fc4">yield_now<span class="fc5">();</span></span> </div><div class="t m0 x4 hc y11d ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;yield_now in another thread!&quot;</span>);</span></span> </div><div class="t m0 x4 hc y11e ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">});</span> </div><div class="t m0 x4 hc y11f ff6 fs4 fc3 sc0 ls0 ws0">    handle1<span class="fc5">.<span class="fc4">join</span>().<span class="fc4">unwrap</span>();</span> </div><div class="t m0 x4 hc y120 ff6 fs4 fc3 sc0 ls0 ws0">    handle2<span class="fc5">.<span class="fc4">join</span>().<span class="fc4">unwrap</span>();</span> </div><div class="t m0 x4 hc y121 ff6 fs4 fc5 sc0 ls0 ws0">}</div></div><div class="c x0 yf0 w2 h1e"><div class="t m0 xa h6 y122 ff6 fs4 fc0 sc0 ls0 ws0">sleep<span class="_ _3"> </span><span class="ff1 fs2">给了调用者让线程休眠一个指定时间的权利，当休眠时间确定的情况下我们可以使用它。</span></div><div class="t m0 x2 h6 y123 ff1 fs2 fc0 sc0 ls0 ws0">如果在休眠时间不确定的情况下，我们想让某个线程休眠，将来在某个事件发生之后，我们再主</div><div class="t m0 x2 h6 y124 ff1 fs2 fc0 sc0 ls0 ws0">动的唤醒它，那么就可以使用我们前面介绍的<span class="_ _3"> </span><span class="ff6 fs4">park<span class="_ _3"> </span></span>和<span class="_ _3"> </span><span class="ff6 fs4">unpark<span class="_ _3"> </span></span>方法了。</div><div class="t m0 x2 h6 y125 ff1 fs2 fc0 sc0 ls0 ws0">你可以认为每个线程都有一个令牌<span class="ff5">(<span class="_ _3"> </span><span class="ff6 fs4">token<span class="_ _3"> </span></span>),</span>最初该令牌不存在。</div><div class="t m0 x11 h6 y126 ff6 fs4 fc0 sc0 ls0 ws0">thread::park<span class="_ _3"> </span><span class="ff1 fs2">将阻塞当前线程，直到线程的令牌可用。此时它以原子操作的使用令牌。</span></div><div class="t m0 x11 h6 y127 ff6 fs4 fc0 sc0 ls0 ws0">thread::park_timeout<span class="_ _3"> </span><span class="ff1 fs2">执行相同的操作，但允许指定阻止线程的最长时间。和<span class="_ _3"> </span></span>sleep<span class="_ _3"> </span><span class="ff1 fs2">不同，</span></div><div class="t m0 x3 h6 y128 ff1 fs2 fc0 sc0 ls0 ws0">它可以还未到超时的时候就被唤醒。</div><div class="t m0 x11 h6 y129 ff6 fs4 fc0 sc0 ls0 ws0">thread.upark<span class="_ _3"> </span><span class="ff1 fs2">方法以原子方式使令牌可用（如果尚未可用）。由于令牌初始不存在，</span></div><div class="t m0 x11 h6 y12a ff6 fs4 fc0 sc0 ls0 ws0">unpark<span class="_ _3"> </span><span class="ff1 fs2">会导致紧接着的<span class="_ _3"> </span></span>park<span class="_ _3"> </span><span class="ff1 fs2">调用立即返回。</span></div></div><div class="c x0 y12b w2 h22"><div class="t m0 x4 hc y12c ff6 fs4 fc2 sc0 ls0 ws0">pub<span class="fc3"> </span>fn<span class="fc3"> <span class="fc4">thread_park<span class="fc5">()</span></span> <span class="fc5">{</span> </span></div><div class="t m0 x4 hc y12d ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> handle <span class="fc6">=</span> <span class="_ _2"> </span><span class="fc4">spawn<span class="fc5">(||</span></span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y12e ff6 fs4 fc3 sc0 ls0 ws0">        <span class="_ _2"> </span><span class="fc4">park<span class="fc5">();</span></span> </div><div class="t m0 x4 hc y12f ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;Hello from a park thread!&quot;</span>);</span></span> </div><div class="t m0 x4 hc y130 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">});</span> </div><div class="t m0 x4 hc y131 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="_ _2"> </span><span class="fc4">sleep<span class="fc5">(</span>Duration<span class="fc5">::</span>from_millis<span class="fc5">(<span class="fc7">1000</span>));</span></span> </div><div class="t m0 x4 hc y132 ff6 fs4 fc3 sc0 ls0 ws0">    handle<span class="fc5">.<span class="fc4">thread</span>().<span class="fc4">unpark</span>();</span> </div><div class="t m0 x4 hc y133 ff6 fs4 fc3 sc0 ls0 ws0">    handle<span class="fc5">.<span class="fc4">join</span>().<span class="fc4">unwrap</span>();</span> </div><div class="t m0 x4 hc y134 ff6 fs4 fc5 sc0 ls0 ws0">}</div></div><div class="c x0 yf0 w2 h1e"><div class="t m0 x2 h6 y135 ff1 fs2 fc0 sc0 ls0 ws0">如果先调用<span class="_ _3"> </span><span class="ff6 fs4">unpark<span class="_ _3"> </span></span><span class="ff5">,</span>接下来的那个<span class="_ _3"> </span><span class="ff6 fs4">park<span class="_ _3"> </span></span>会立即返回：</div></div><div class="c x6 y9f w5 h13"><div class="t m0 x2 hc y136 ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><div class="c x10 y137 w5 h13"><div class="t m0 x2 hc y138 ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><div class="c x6 y139 w5 h13"><div class="t m0 x2 hc y13a ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><div class="c x10 y13b w5 h13"><div class="t m0 x2 hc y13c ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><div class="c x5 y13d w4 h13"><div class="t m0 x2 hc y13e ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><div class="c x10 y13f w5 h13"><div class="t m0 x2 hc y140 ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><div class="c x8 y141 w5 h13"><div class="t m0 x2 hc y142 ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div></div><div class="pi" data-data='{"ctm":[1.000000,0.000000,0.000000,1.000000,0.000000,0.000000]}'></div></div>
<div id="pfa" class="pf w0 h0" data-page-no="a"><div class="pc pca w0 h0"><img class="bi x0 y0 w3 h1" alt="" src="bga.png"/><div class="c x0 yc7 w2 h2"><div class="t m0 x1 h3 y2 ff1 fs0 fc0 sc0 ls0 ws0">鸟窝<span class="ff2"> - https://github.com/smallnest/concurrency-programming-via-rust</span></div></div><div class="c x0 y143 w2 h23"><div class="t m0 x4 hc y144 ff6 fs4 fc2 sc0 ls0 ws0">pub<span class="fc3"> </span>fn<span class="fc3"> <span class="fc4">thread_park2<span class="fc5">()</span></span> <span class="fc5">{</span> </span></div><div class="t m0 x4 hc y145 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> handle <span class="fc6">=</span> <span class="_ _2"> </span><span class="fc4">spawn<span class="fc5">(||</span></span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y146 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="_ _2"> </span><span class="fc4">sleep<span class="fc5">(</span>Duration<span class="fc5">::</span>from_millis<span class="fc5">(<span class="fc7">1000</span>));</span></span> </div><div class="t m0 x4 hc y147 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="_ _2"> </span><span class="fc4">park<span class="fc5">();</span></span> </div><div class="t m0 x4 hc y148 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;Hello from a park thread in case of unpark first!&quot;</span>);</span></span> </div><div class="t m0 x4 hc y149 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">});</span> </div><div class="t m0 x4 hc y14a ff6 fs4 fc3 sc0 ls0 ws0">    handle<span class="fc5">.<span class="fc4">thread</span>().<span class="fc4">unpark</span>();</span> </div><div class="t m0 x4 hc y14b ff6 fs4 fc3 sc0 ls0 ws0">    handle<span class="fc5">.<span class="fc4">join</span>().<span class="fc4">unwrap</span>();</span> </div><div class="t m0 x4 hc y14c ff6 fs4 fc5 sc0 ls0 ws0">}</div></div><div class="c x0 yc8 w2 h19"><div class="t m0 x2 h6 y14d ff1 fs2 fc0 sc0 ls0 ws0">如果预先调用一股脑的<span class="_ _3"> </span><span class="ff6 fs4">unpark<span class="_ _3"> </span></span>多次，然后再一股脑的调用<span class="_ _3"> </span><span class="ff6 fs4">park<span class="_ _3"> </span></span>行不行，如下所示<span class="ff5">:</span></div></div><div class="c x0 y14e w2 h24"><div class="t m0 x4 hc y14f ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> handle <span class="fc6">=</span> <span class="_ _2"> </span><span class="fc4">spawn<span class="fc5">(||</span></span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y150 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="_ _2"> </span><span class="fc4">sleep<span class="fc5">(</span>Duration<span class="fc5">::</span>from_millis<span class="fc5">(<span class="fc7">1000</span>));</span></span> </div><div class="t m0 x4 hc y151 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="_ _2"> </span><span class="fc4">park<span class="fc5">();</span></span> </div><div class="t m0 x4 hc y152 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="_ _2"> </span><span class="fc4">park<span class="fc5">();</span></span> </div><div class="t m0 x4 hc y153 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="_ _2"> </span><span class="fc4">park<span class="fc5">();</span></span> </div><div class="t m0 x4 hc y154 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;Hello from a park thread in case of unpark first!&quot;</span>);</span></span> </div><div class="t m0 x4 hc y155 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">});</span> </div><div class="t m0 x4 hc y156 ff6 fs4 fc3 sc0 ls0 ws0">    handle<span class="fc5">.<span class="fc4">thread</span>().<span class="fc4">unpark</span>();</span> </div><div class="t m0 x4 hc y157 ff6 fs4 fc3 sc0 ls0 ws0">    handle<span class="fc5">.<span class="fc4">thread</span>().<span class="fc4">unpark</span>();</span> </div><div class="t m0 x4 hc y158 ff6 fs4 fc3 sc0 ls0 ws0">    handle<span class="fc5">.<span class="fc4">thread</span>().<span class="fc4">unpark</span>();</span> </div><div class="t m0 x4 hc y159 ff6 fs4 fc3 sc0 ls0 ws0">    handle<span class="fc5">.<span class="fc4">join</span>().<span class="fc4">unwrap</span>();</span></div></div><div class="c x0 yc8 w2 h19"><div class="t m0 x2 h6 y15a ff1 fs2 fc0 sc0 ls0 ws0">答案是不行。因为一个线程只有一个令牌，这个令牌或者存在或者只有一个，多次调用<span class="_ _3"> </span><span class="ff6 fs4">unpark<span class="_ _3"> </span></span>也</div><div class="t m0 x2 h6 y15b ff1 fs2 fc0 sc0 ls0 ws0">是针对一个令牌进行的的操作，上面的代码会导致新建的那个线程一直处于<span class="_ _3"> </span><span class="ff6 fs4">parked<span class="_ _3"> </span></span>状态。</div><div class="t m0 x12 h6 y15c ff1 fs2 fca sc0 ls0 ws0">依照官方的文档，<span class="ff5"> <span class="_ _3"> </span><span class="ff6 fs4">park<span class="_ _3"> </span></span></span>函数的调用并不保证线程永远保持<span class="ff5">parked</span>状态，调用者应该小心这</div><div class="t m0 x12 h6 y15d ff1 fs2 fca sc0 ls0 ws0">种可能性。</div><div class="t m0 x2 h12 y15e ff4 fs3 fc0 sc0 ls0 ws0">scoped thread</div><div class="t m0 xa h6 y15f ff6 fs4 fc0 sc0 ls0 ws0">thread::scope<span class="_ _3"> </span><span class="ff1 fs2">函数提供了创建<span class="ff5">scoped thread</span>的可能性。<span class="ff5">scoped thread</span>不同于上面我们创建的</span></div><div class="t m0 x2 h6 y160 ff5 fs2 fc0 sc0 ls0 ws0">thread, <span class="ff1">它可以借用</span>scope<span class="ff1">外部的非<span class="_ _3"> </span><span class="ff6 fs4">&apos;static&apos;<span class="_ _3"> </span></span>数据。</span></div><div class="t m0 x2 h6 y161 ff1 fs2 fc0 sc0 ls0 ws0">使用<span class="_ _3"> </span><span class="ff6 fs4">thread::scope<span class="_ _3"> </span></span>函数提供的<span class="ff5 fc1">Scope</span>的参数，可以创建<span class="ff5">(spawn) scoped thread</span>。创建出来的</div><div class="t m0 x2 h6 y162 ff5 fs2 fc0 sc0 ls0 ws0">scoped thread<span class="ff1">如果没有手工调用<span class="_ _3"> </span><span class="ff6 fs4">join<span class="_ _3"> </span></span></span>,<span class="ff1">在这个函数返回前会自动<span class="_ _3"> </span><span class="ff6 fs4">join<span class="_ _3"> </span></span>。</span></div></div><div class="c x5 y9f w4 h13"><div class="t m0 x2 hc y163 ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><div class="c x10 y137 w5 h13"><div class="t m0 x2 hc y164 ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><div class="c x10 y165 w5 h13"><div class="t m0 x2 hc y166 ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><div class="c x5 y167 w4 h13"><div class="t m0 x2 hc y168 ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><div class="c x10 y169 w5 h13"><div class="t m0 x2 hc y16a ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><div class="c x10 y16b w5 h13"><div class="t m0 x2 hc y16c ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><div class="c x10 y16d w5 h13"><div class="t m0 x2 hc y16e ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><div class="c x10 y16f w5 h13"><div class="t m0 x2 hc y170 ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><a class="l" href="https://doc.rust-lang.org/stable/std/thread/struct.Scope.html"><div class="d m1" style="border-style:none;position:absolute;left:206.330380px;bottom:147.898071px;width:32.265780px;height:15.757508px;background-color:rgba(255,255,255,0.000001);"></div></a></div><div class="pi" data-data='{"ctm":[1.000000,0.000000,0.000000,1.000000,0.000000,0.000000]}'></div></div>
<div id="pfb" class="pf w0 h0" data-page-no="b"><div class="pc pcb w0 h0"><img class="bi x0 y0 w3 h1" alt="" src="bgb.png"/><div class="c x0 y59 w2 h2"><div class="t m0 x1 h3 y2 ff1 fs0 fc0 sc0 ls0 ws0">鸟窝<span class="ff2"> - https://github.com/smallnest/concurrency-programming-via-rust</span></div></div><div class="c x0 y171 w2 h25"><div class="t m0 x4 hc y172 ff6 fs4 fc2 sc0 ls0 ws0">pub<span class="fc3"> </span>fn<span class="fc3"> <span class="fc4">wrong_start_threads_without_scoped<span class="fc5">()</span></span> <span class="fc5">{</span> </span></div><div class="t m0 x4 hc y173 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> <span class="fc2">mut</span> a <span class="fc6">=</span> <span class="fc7">vec!<span class="fc5">[</span>1<span class="fc5">,</span></span> <span class="fc7">2<span class="fc5">,</span></span> <span class="fc7">3<span class="fc5">];</span></span> </div><div class="t m0 x4 hc y174 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> <span class="fc2">mut</span> x <span class="fc6">=</span> <span class="fc7">0<span class="fc5">;</span></span> </div><div class="t m0 x4 hc y175 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="_ _2"> </span><span class="fc4">spawn<span class="fc5">(<span class="fc2">move</span></span></span> <span class="fc5">||</span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y176 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;hello from the first scoped thread&quot;</span>);</span></span> </div><div class="t m0 x4 hc y177 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">dbg!<span class="fc5">(<span class="fc6">&amp;</span></span></span>a<span class="fc5">);</span> </div><div class="t m0 x4 hc y178 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">});</span> </div><div class="t m0 x4 hc y179 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="_ _2"> </span><span class="fc4">spawn<span class="fc5">(<span class="fc2">move</span></span></span> <span class="fc5">||</span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y17a ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;hello from the second scoped thread&quot;</span>);</span></span> </div><div class="t m0 x4 hc y17b ff6 fs4 fc3 sc0 ls0 ws0">        x <span class="fc6">+=</span> a<span class="fc5">[<span class="fc7">0</span>]</span> <span class="fc6">+</span> a<span class="fc5">[<span class="fc7">2</span>];</span> </div><div class="t m0 x4 hc y17c ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">});</span> </div><div class="t m0 x4 hc y17d ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;hello from the main thread&quot;</span>);</span></span> </div><div class="t m0 x4 hc y17e ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc9">// After the scope, we can modify and access our variables again:</span> </div><div class="t m0 x4 hc y17f ff6 fs4 fc3 sc0 ls0 ws0">    a<span class="fc5">.<span class="fc4">push</span>(<span class="fc7">4</span>);</span> </div><div class="t m0 x4 hc y180 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc7">assert_eq!<span class="fc5">(</span></span>x<span class="fc5">,</span> a<span class="fc5">.<span class="fc4">len</span>());</span> </div><div class="t m0 x4 hc y181 ff6 fs4 fc5 sc0 ls0 ws0">}</div></div><div class="c x0 yf0 w2 h1e"><div class="t m0 x2 h6 y182 ff1 fs2 fc0 sc0 ls0 ws0">这段代码是无法编译的，因为线程外的<span class="_ _3"> </span><span class="ff6 fs4">a<span class="_ _3"> </span></span>没有办法<span class="ff5">move</span>到两个<span class="ff5">thread</span>中，即使<span class="ff5">move</span>到一个</div><div class="t m0 x2 h6 y183 ff5 fs2 fc0 sc0 ls0 ws0">thread,<span class="ff1">外部的线程也没有办法再使用它了。为了解决这个问题，我们可以使用</span>scoped thread:</div></div><div class="c x0 y184 w2 h26"><div class="t m0 x4 hc y185 ff6 fs4 fc2 sc0 ls0 ws0">pub<span class="fc3"> </span>fn<span class="fc3"> <span class="fc4">start_scoped_threads<span class="fc5">()</span></span> <span class="fc5">{</span> </span></div><div class="t m0 x4 hc y186 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> <span class="fc2">mut</span> a <span class="fc6">=</span> <span class="fc7">vec!<span class="fc5">[</span>1<span class="fc5">,</span></span> <span class="fc7">2<span class="fc5">,</span></span> <span class="fc7">3<span class="fc5">];</span></span> </div><div class="t m0 x4 hc y187 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> <span class="fc2">mut</span> x <span class="fc6">=</span> <span class="fc7">0<span class="fc5">;</span></span> </div><div class="t m0 x4 hc y188 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="_ _2"> </span><span class="fc4">scope<span class="fc5">(|</span></span>s<span class="fc5">|</span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y189 ff6 fs4 fc3 sc0 ls0 ws0">        s<span class="fc5">.<span class="fc4">spawn</span>(||</span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y18a ff6 fs4 fc3 sc0 ls0 ws0">            <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;hello from the first scoped thread&quot;</span>);</span></span> </div><div class="t m0 x4 hc y18b ff6 fs4 fc3 sc0 ls0 ws0">            <span class="fc7">dbg!<span class="fc5">(<span class="fc6">&amp;</span></span></span>a<span class="fc5">);</span> </div><div class="t m0 x4 hc y18c ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc5">});</span> </div><div class="t m0 x4 hc y18d ff6 fs4 fc3 sc0 ls0 ws0">        s<span class="fc5">.<span class="fc4">spawn</span>(||</span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y18e ff6 fs4 fc3 sc0 ls0 ws0">            <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;hello from the second scoped thread&quot;</span>);</span></span> </div><div class="t m0 x4 hc y18f ff6 fs4 fc3 sc0 ls0 ws0">            x <span class="fc6">+=</span> a<span class="fc5">[<span class="fc7">0</span>]</span> <span class="fc6">+</span> a<span class="fc5">[<span class="fc7">2</span>];</span> </div><div class="t m0 x4 hc y190 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc5">});</span> </div><div class="t m0 x4 hc y191 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;hello from the main thread&quot;</span>);</span></span> </div><div class="t m0 x4 hc y192 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">});</span> </div><div class="t m0 x4 h27 y193 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc9">// scope<span class="ff7">执<span class="_ _a"></span>行<span class="_ _a"></span>完<span class="_ _a"></span></span>, <span class="ff7">我<span class="_ _a"></span>们<span class="_ _a"></span>又<span class="_ _a"></span>可<span class="_ _a"></span>以<span class="_ _a"></span>修<span class="_ _a"></span>改<span class="_ _a"></span>和<span class="_ _a"></span>访<span class="_ _a"></span>问<span class="_ _a"></span>变<span class="_ _a"></span>量<span class="_ _a"></span></span>we can modify and access our variables </span></div><div class="t m0 x4 hc y194 ff6 fs4 fc9 sc0 ls0 ws0">again:<span class="fc3"> </span></div><div class="t m0 x4 hc y195 ff6 fs4 fc3 sc0 ls0 ws0">    a<span class="fc5">.<span class="fc4">push</span>(<span class="fc7">4</span>);</span> </div><div class="t m0 x4 hc y196 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc7">assert_eq!<span class="fc5">(</span></span>x<span class="fc5">,</span> a<span class="fc5">.<span class="fc4">len</span>());</span> </div><div class="t m0 x4 hc y197 ff6 fs4 fc5 sc0 ls0 ws0">}</div></div><div class="c x8 yc3 w5 h13"><div class="t m0 x2 hc y198 ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><div class="c x8 y199 w5 h13"><div class="t m0 x2 hc y19a ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><div class="c x8 y19b w5 h13"><div class="t m0 x2 hc y19c ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div></div><div class="pi" data-data='{"ctm":[1.000000,0.000000,0.000000,1.000000,0.000000,0.000000]}'></div></div>
<div id="pfc" class="pf w0 h0" data-page-no="c"><div class="pc pcc w0 h0"><img class="bi x0 y0 w3 h7" alt="" src="bgc.png"/><div class="c x0 y19d w2 h2"><div class="t m0 x1 h3 y2 ff1 fs0 fc0 sc0 ls0 ws0">鸟窝<span class="ff2"> - https://github.com/smallnest/concurrency-programming-via-rust</span></div></div><div class="c x0 y19e w2 h28"><div class="t m0 x2 h6 y19f ff1 fs2 fc0 sc0 ls0 ws0">这里我们调用了<span class="_ _3"> </span><span class="ff6 fs4">thread::scope<span class="_ _3"> </span></span>函数，并使用<span class="ff5">s</span>参数启动了两个<span class="ff5">scoped thread, </span>它们使用了外部的</div><div class="t m0 x2 h6 y1a0 ff1 fs2 fc0 sc0 ls0 ws0">变量<span class="_ _3"> </span><span class="ff6 fs4">a<span class="_ _3"> </span></span>和<span class="_ _3"> </span><span class="ff6 fs4">x<span class="_ _3"> </span></span>。<span class="ff5"> </span>因为我们对<span class="_ _3"> </span><span class="ff6 fs4">a<span class="_ _3"> </span></span>只是读，对<span class="_ _3"> </span><span class="ff6 fs4">x<span class="_ _3"> </span></span>只有单线程的写，所以不用考虑并发问题。</div><div class="t m0 xa h6 y1a1 ff6 fs4 fc0 sc0 ls0 ws0">thread::scope<span class="_ _3"> </span><span class="ff1 fs2">返回后，两个线程已经执行完毕，所以外部的线程又可以访问变量了。</span></div><div class="t m0 x2 h6 y1a2 ff1 fs2 fc0 sc0 ls0 ws0">标准库的<span class="ff5">scope</span>功能并没有进一步扩展，事实上我们可以看到，在新的<span class="ff5">scoped thread,</span>我们是不是</div><div class="t m0 x2 h6 y1a3 ff1 fs2 fc0 sc0 ls0 ws0">还可以启动新的<span class="ff5">scope</span>线程，这样实现类似<span class="ff5">java</span>一样的<span class="_ _3"> </span><span class="ff6 fs4">Fork-Join<span class="_ _3"> </span></span>父子线程。不过如果你有这个需</div><div class="t m0 x2 h6 y1a4 ff1 fs2 fc0 sc0 ls0 ws0">求，可以通过第三方的库实现。</div><div class="t m0 x2 h12 y1a5 ff4 fs3 fc0 sc0 ls0 ws0">ThreadLocal</div><div class="t m0 x2 h6 y1a6 ff5 fs2 fc0 sc0 ls0 ws0">ThreadLocal <span class="ff1">为</span>Rust<span class="ff1">程序提供了</span> thread-local storage<span class="ff1">的实现。</span>TLS(thread-local storage)<span class="ff1">可以存储</span></div><div class="t m0 x2 h6 y1a7 ff1 fs2 fc0 sc0 ls0 ws0">数据到全局变量中，每个线程都有这个存储变量的副本，线程不会分享这个数据，副本是线程独</div><div class="t m0 x2 h6 y1a8 ff1 fs2 fc0 sc0 ls0 ws0">有的，所以对它的访问不需要同步控制。<span class="ff5">Java</span>中也有类似的数据结构，但是<span class="ff5">Go</span>官方不建议实现</div><div class="t m0 x2 h6 y1a9 ff5 fs2 fc0 sc0 ls0 ws0">goroutine-local storage<span class="ff1">。</span></div><div class="t m0 x2 h6 y1aa ff5 fs2 fc0 sc0 ls0 ws0">thread-local key<span class="ff1">拥有它的值，并且在线程退出此值会被销毁。我们使用<span class="_ _3"> </span><span class="ff6 fs4">thread_local!<span class="_ _3"> </span></span>宏创建</span></div><div class="t m0 x2 h6 y1ab ff5 fs2 fc0 sc0 ls0 ws0">thread-local key,<span class="ff1">它可以包含<span class="_ _3"> </span><span class="ff6 fs4">&apos;static<span class="_ _3"> </span></span>的值。它使用<span class="_ _3"> </span><span class="ff6 fs4">with<span class="_ _3"> </span></span>访问函数去访问值。如果我们想修改</span></div><div class="t m0 x2 h6 y1ac ff1 fs2 fc0 sc0 ls0 ws0">值，我们还需要结合<span class="_ _3"> </span><span class="ff6 fs4">Cell<span class="_ _3"> </span></span>和<span class="_ _3"> </span><span class="ff6 fs4">RefCell<span class="_ _3"> </span></span><span class="ff5">,</span>这两个类型我们后面同步原语章节中再介绍，当前你可以</div><div class="t m0 x2 h6 y1ad ff1 fs2 fc0 sc0 ls0 ws0">理解它们为不可变变量提供内部可修改性。</div><div class="t m0 x2 h6 y1ae ff1 fs2 fc0 sc0 ls0 ws0">一个<span class="ff5">ThreadLocal</span>例子如下：</div></div></div><div class="pi" data-data='{"ctm":[1.000000,0.000000,0.000000,1.000000,0.000000,0.000000]}'></div></div>
<div id="pfd" class="pf w0 h0" data-page-no="d"><div class="pc pcd w0 h0"><img class="bi x0 y0 w3 h7" alt="" src="bgd.png"/><div class="c x0 y1af w2 h29"><div class="t m0 x1 h3 y1b0 ff1 fs0 fc0 sc0 ls0 ws0">鸟窝<span class="ff2"> - https://github.com/smallnest/concurrency-programming-via-rust</span></div></div><div class="c x0 y1b1 w2 h2a"><div class="t m0 x4 hc y1b2 ff6 fs4 fc2 sc0 ls0 ws0">pub<span class="fc3"> </span>fn<span class="fc3"> <span class="fc4">start_threads_with_threadlocal<span class="fc5">()</span></span> <span class="fc5">{</span> </span></div><div class="t m0 x4 hc y1b3 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc7">thread_local!<span class="fc5">(<span class="fc2">static</span></span></span> <span class="fc7">COUNTER<span class="fc5">:</span></span> <span class="fc4">RefCell<span class="fc6">&lt;<span class="fc2">u32</span>&gt;</span></span> <span class="fc6">=</span> <span class="fc4">RefCell<span class="fc5">::</span>new<span class="fc5">(<span class="fc7">1</span>));</span></span> </div><div class="t m0 x4 hc y1b4 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc7">COUNTER<span class="fc5">.<span class="fc4">with</span>(|</span></span>c<span class="fc5">|</span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y1b5 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc6">*</span>c<span class="fc5">.<span class="fc4">borrow_mut</span>()</span> <span class="fc6">=</span> <span class="fc7">2<span class="fc5">;</span></span> </div><div class="t m0 x4 hc y1b6 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">});</span> </div><div class="t m0 x4 hc y1b7 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> handle1 <span class="fc6">=</span> <span class="_ _2"> </span><span class="fc4">spawn<span class="fc5">(<span class="fc2">move</span></span></span> <span class="fc5">||</span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y1b8 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">COUNTER<span class="fc5">.<span class="fc4">with</span>(|</span></span>c<span class="fc5">|</span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y1b9 ff6 fs4 fc3 sc0 ls0 ws0">            <span class="fc6">*</span>c<span class="fc5">.<span class="fc4">borrow_mut</span>()</span> <span class="fc6">=</span> <span class="fc7">3<span class="fc5">;</span></span> </div><div class="t m0 x4 hc y1ba ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc5">});</span> </div><div class="t m0 x4 hc y1bb ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">COUNTER<span class="fc5">.<span class="fc4">with</span>(|</span></span>c<span class="fc5">|</span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y1bc ff6 fs4 fc3 sc0 ls0 ws0">            <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;Hello from a thread7, c={}!&quot;</span>,</span></span> <span class="fc6">*</span>c<span class="fc5">.<span class="fc4">borrow</span>());</span> </div><div class="t m0 x4 hc y1bd ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc5">});</span> </div><div class="t m0 x4 hc y1be ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">});</span> </div><div class="t m0 x4 hc y1bf ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> handle2 <span class="fc6">=</span> <span class="_ _2"> </span><span class="fc4">spawn<span class="fc5">(<span class="fc2">move</span></span></span> <span class="fc5">||</span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y1c0 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">COUNTER<span class="fc5">.<span class="fc4">with</span>(|</span></span>c<span class="fc5">|</span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y1c1 ff6 fs4 fc3 sc0 ls0 ws0">            <span class="fc6">*</span>c<span class="fc5">.<span class="fc4">borrow_mut</span>()</span> <span class="fc6">=</span> <span class="fc7">4<span class="fc5">;</span></span> </div><div class="t m0 x4 hc y1c2 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc5">});</span> </div><div class="t m0 x4 hc y1c3 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">COUNTER<span class="fc5">.<span class="fc4">with</span>(|</span></span>c<span class="fc5">|</span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y1c4 ff6 fs4 fc3 sc0 ls0 ws0">            <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;Hello from a thread8, c={}!&quot;</span>,</span></span> <span class="fc6">*</span>c<span class="fc5">.<span class="fc4">borrow</span>());</span> </div><div class="t m0 x4 hc y1c5 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc5">});</span> </div><div class="t m0 x4 hc y1c6 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">});</span> </div><div class="t m0 x4 hc y1c7 ff6 fs4 fc3 sc0 ls0 ws0">    handle1<span class="fc5">.<span class="fc4">join</span>().<span class="fc4">unwrap</span>();</span> </div><div class="t m0 x4 hc y1c8 ff6 fs4 fc3 sc0 ls0 ws0">    handle2<span class="fc5">.<span class="fc4">join</span>().<span class="fc4">unwrap</span>();</span> </div><div class="t m0 x4 hc y1c9 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc7">COUNTER<span class="fc5">.<span class="fc4">with</span>(|</span></span>c<span class="fc5">|</span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y1ca ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;Hello from main, c={}!&quot;</span>,</span></span> <span class="fc6">*</span>c<span class="fc5">.<span class="fc4">borrow</span>());</span> </div><div class="t m0 x4 hc y1cb ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">});</span> </div><div class="t m0 x4 hc y1cc ff6 fs4 fc5 sc0 ls0 ws0">}<span class="fc3"> </span></div></div><div class="c x0 y19e w2 h28"><div class="t m0 x2 h6 y1cd ff1 fs2 fc0 sc0 ls0 ws0">在这个例子中，我们定义了一个<span class="ff5">Thread_local key: <span class="ff4">COUNTER</span></span>。在外部线程和两个子线程中使用</div><div class="t m0 xa h6 y1ce ff6 fs4 fc0 sc0 ls0 ws0">with<span class="_ _3"> </span><span class="ff1 fs2">修改了<span class="ff4">COUNTER<span class="ff5">,</span></span>但是修改<span class="ff4">C<span class="_ _1"></span>OUNTER<span class="ff1">只会影响本线程。可以看到最后外部线程输出的</span></span></span></div><div class="t m0 x2 h6 y1cf ff4 fs2 fc0 sc0 ls0 ws0">COUNTER<span class="ff5"> <span class="ff1">的值是</span>2<span class="ff1">，</span> <span class="ff1">尽管两个子线程修改了</span></span>C<span class="_ _1"></span>OUNTER<span class="ff1">的值为<span class="ff5">3</span>和<span class="ff5">4</span>。</span></div><div class="t m0 x2 h12 y1d0 ff4 fs3 fc0 sc0 ls0 ws0">Move</div><div class="t m0 x2 h6 y1d1 ff1 fs2 fc0 sc0 ls0 ws0">在前面的例子中，我们可以看到有时候在调用<span class="_ _3"> </span><span class="ff6 fs4">thread::spawn<span class="_ _3"> </span></span>的时候，有时候会使用<span class="_ _3"> </span><span class="ff6 fs4">move<span class="_ _3"> </span></span>，有时</div><div class="t m0 x2 h6 y1d2 ff1 fs2 fc0 sc0 ls0 ws0">候没有使用<span class="_ _3"> </span><span class="ff6 fs4">move<span class="_ _3"> </span></span>。</div></div><div class="c x6 y199 w5 h13"><div class="t m0 x2 hc y1d3 ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><div class="c x6 y1d4 w5 h13"><div class="t m0 x2 hc y1d5 ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div></div><div class="pi" data-data='{"ctm":[1.000000,0.000000,0.000000,1.000000,0.000000,0.000000]}'></div></div>
<div id="pfe" class="pf w0 h0" data-page-no="e"><div class="pc pce w0 h0"><img class="bi x0 y0 w3 h7" alt="" src="bge.png"/><div class="c x0 yc7 w2 h2"><div class="t m0 x1 h3 y2 ff1 fs0 fc0 sc0 ls0 ws0">鸟窝<span class="ff2"> - https://github.com/smallnest/concurrency-programming-via-rust</span></div></div><div class="c x0 y1d6 w2 h2b"><div class="t m0 x2 h6 y1d7 ff1 fs2 fc0 sc0 ls0 ws0">使不使用<span class="_ _3"> </span><span class="ff6 fs4">move<span class="_ _3"> </span></span>依赖相应的闭包是否要获取外部变量的所有权。如果不获取外部变量的所有权，则</div><div class="t m0 x2 h6 y1d8 ff1 fs2 fc0 sc0 ls0 ws0">可以不使用<span class="_ _3"> </span><span class="ff6 fs4">move<span class="_ _3"> </span></span><span class="ff5">,</span>大部分情况下我们会使用外部变量，所以这里<span class="_ _3"> </span><span class="ff6 fs4">move<span class="_ _3"> </span></span>更常见<span class="ff5">:</span></div></div><div class="c x0 y1d9 w2 h2c"><div class="t m0 x4 hc y1da ff6 fs4 fc2 sc0 ls0 ws0">pub<span class="fc3"> </span>fn<span class="fc3"> <span class="fc4">start_one_thread_with_move<span class="fc5">()</span></span> <span class="fc5">{</span> </span></div><div class="t m0 x4 hc y1db ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> x <span class="fc6">=</span> <span class="fc7">100<span class="fc5">;</span></span> </div><div class="t m0 x4 hc y1dc ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> handle <span class="fc6">=</span> <span class="_ _2"> </span><span class="fc4">spawn<span class="fc5">(<span class="fc2">move</span></span></span> <span class="fc5">||</span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y1dd ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;Hello from a thread with move, x={}!&quot;</span>,</span></span> x<span class="fc5">);</span> </div><div class="t m0 x4 hc y1de ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">});</span> </div><div class="t m0 x4 hc y1df ff6 fs4 fc3 sc0 ls0 ws0">    handle<span class="fc5">.<span class="fc4">join</span>().<span class="fc4">unwrap</span>();</span> </div><div class="t m0 x4 hc y1e0 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> handle <span class="fc6">=</span> <span class="_ _2"> </span><span class="fc4">spawn<span class="fc5">(<span class="fc2">move</span>||</span></span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y1e1 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;Hello from a thread with move again, x={}!&quot;</span>,</span></span> x<span class="fc5">);</span> </div><div class="t m0 x4 hc y1e2 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">});</span> </div><div class="t m0 x4 hc y1e3 ff6 fs4 fc3 sc0 ls0 ws0">    handle<span class="fc5">.<span class="fc4">join</span>().<span class="fc4">unwrap</span>();</span> </div><div class="t m0 x4 hc y1e4 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> handle <span class="fc6">=</span> <span class="_ _2"> </span><span class="fc4">spawn<span class="fc5">(||</span></span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y1e5 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;Hello from a thread without move&quot;</span>);</span></span> </div><div class="t m0 x4 hc y1e6 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">});</span> </div><div class="t m0 x4 hc y1e7 ff6 fs4 fc3 sc0 ls0 ws0">    handle<span class="fc5">.<span class="fc4">join</span>().<span class="fc4">unwrap</span>();</span> </div><div class="t m0 x4 hc y1e8 ff6 fs4 fc5 sc0 ls0 ws0">}</div></div><div class="c x0 y1d6 w2 h2b"><div class="t m0 x2 h6 y1e9 ff1 fs2 fc0 sc0 ls0 ws0">当我们在线程中引用变量<span class="_ _3"> </span><span class="ff6 fs4">x<span class="_ _3"> </span></span>时，我们使用了<span class="_ _3"> </span><span class="ff6 fs4">move<span class="_ _3"> </span></span><span class="ff5">,</span>当我们没引用变量，我们没使用<span class="_ _3"> </span><span class="ff6 fs4">move<span class="_ _3"> </span></span>。</div><div class="t m0 x2 h6 y1ea ff1 fs2 fc0 sc0 ls0 ws0">这里有一个问题，<span class="_ _3"> </span><span class="ff6 fs4">move<span class="_ _3"> </span></span>不是把<span class="_ _3"> </span><span class="ff6 fs4">x<span class="_ _3"> </span></span>的所有权交给了第一个子线程了么，为什么第二个子线程依然</div><div class="t m0 x2 h6 y1eb ff1 fs2 fc0 sc0 ls0 ws0">可以<span class="ff5">move</span>并使用<span class="ff5">x</span>呢？</div><div class="t m0 x2 h6 y1ec ff1 fs2 fc0 sc0 ls0 ws0">这是因为<span class="ff5">x</span>变量是<span class="_ _3"> </span><span class="ff6 fs4">i32<span class="_ _3"> </span></span>类型的，它实现了<span class="_ _3"> </span><span class="ff6 fs4">Copy<span class="_ _3"> </span></span><span class="ff5"> trait,</span>实际<span class="ff5">move</span>的时候实际复制它的的值，如果我</div><div class="t m0 x2 h6 y1ed ff1 fs2 fc0 sc0 ls0 ws0">们把<span class="ff5">x</span>替换成一个未实现<span class="ff5">Copy</span>的类型，类似的代码就无法编译了，因为<span class="ff5">x</span>的所有权已经转移给第一</div><div class="t m0 x2 h6 y1ee ff1 fs2 fc0 sc0 ls0 ws0">个子线程了<span class="ff5">:</span></div></div><div class="c x5 y1ef w4 h13"><div class="t m0 x2 hc y1f0 ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><div class="c x5 y1f1 w4 h13"><div class="t m0 x2 hc y1f2 ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><div class="c x5 y1f3 w4 h13"><div class="t m0 x2 hc y1f4 ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div></div><div class="pi" data-data='{"ctm":[1.000000,0.000000,0.000000,1.000000,0.000000,0.000000]}'></div></div>
<div id="pff" class="pf w0 h0" data-page-no="f"><div class="pc pcf w0 h0"><img class="bi x0 y0 w3 h7" alt="" src="bgf.png"/><div class="c x0 y19d w2 h2"><div class="t m0 x1 h3 y2 ff1 fs0 fc0 sc0 ls0 ws0">鸟窝<span class="ff2"> - https://github.com/smallnest/concurrency-programming-via-rust</span></div></div><div class="c x0 y1f5 w2 h2d"><div class="t m0 x4 hc y1f6 ff6 fs4 fc2 sc0 ls0 ws0">pub<span class="fc3"> </span>fn<span class="fc3"> <span class="fc4">start_one_thread_with_move2<span class="fc5">()</span></span> <span class="fc5">{</span> </span></div><div class="t m0 x4 hc y1f7 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> x <span class="fc6">=</span> <span class="fc7">vec!<span class="fc5">[</span>1<span class="fc5">,</span></span> <span class="fc7">2<span class="fc5">,</span></span> <span class="fc7">3<span class="fc5">];</span></span> </div><div class="t m0 x4 hc y1f8 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> handle <span class="fc6">=</span> <span class="_ _2"> </span><span class="fc4">spawn<span class="fc5">(<span class="fc2">move</span></span></span> <span class="fc5">||</span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y1f9 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;Hello from a thread with move, x={:?}!&quot;</span>,</span></span> x<span class="fc5">);</span> </div><div class="t m0 x4 hc y1fa ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">});</span> </div><div class="t m0 x4 hc y1fb ff6 fs4 fc3 sc0 ls0 ws0">    handle<span class="fc5">.<span class="fc4">join</span>().<span class="fc4">unwrap</span>();</span> </div><div class="t m0 x4 hc y1fc ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> handle <span class="fc6">=</span> <span class="_ _2"> </span><span class="fc4">spawn<span class="fc5">(<span class="fc2">move</span>||</span></span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y1fd ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;Hello from a thread with move again, x={:?}!&quot;</span>,</span></span> x<span class="fc5">);</span> </div><div class="t m0 x4 hc y1fe ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">});</span> </div><div class="t m0 x4 hc y1ff ff6 fs4 fc3 sc0 ls0 ws0">    handle<span class="fc5">.<span class="fc4">join</span>().<span class="fc4">unwrap</span>();</span> </div><div class="t m0 x4 hc y200 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> handle <span class="fc6">=</span> <span class="_ _2"> </span><span class="fc4">spawn<span class="fc5">(||</span></span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y201 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;Hello from a thread without move&quot;</span>);</span></span> </div><div class="t m0 x4 hc y202 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">});</span> </div><div class="t m0 x4 hc y203 ff6 fs4 fc3 sc0 ls0 ws0">    handle<span class="fc5">.<span class="fc4">join</span>().<span class="fc4">unwrap</span>();</span> </div><div class="t m0 x4 hc y204 ff6 fs4 fc5 sc0 ls0 ws0">}</div></div><div class="c x0 y19e w2 h28"><div class="t m0 x2 ha y205 ff3 fs3 fc0 sc0 ls0 ws0">控制新建的线程</div><div class="t m0 x2 h6 y206 ff1 fs2 fc0 sc0 ls0 ws0">从上面所有的例子中，我们貌似没有办法控制创建的子线程，只能傻傻等待它的执行或者忽略它</div><div class="t m0 x2 h6 y207 ff1 fs2 fc0 sc0 ls0 ws0">的执行，并没有办法中途停止它，或者告诉它停止。<span class="ff5">Go</span>创建的<span class="ff5">goroutine</span>也有类似的问题，但是</div><div class="t m0 x2 h6 y208 ff5 fs2 fc0 sc0 ls0 ws0">Go<span class="ff1">提供了<span class="_ _3"> </span><span class="ff6 fs4">Context.WithCancel<span class="_ _3"> </span></span>和<span class="_ _3"> </span><span class="ff6 fs4">channel<span class="_ _3"> </span></span>，父</span>goroutine<span class="ff1">可以传递给子</span>goroutine<span class="ff1">信号。</span>Rust<span class="ff1">也可</span></div><div class="t m0 x2 h6 y209 ff1 fs2 fc0 sc0 ls0 ws0">以实现类似的机制，我们可以使用以后讲到的<span class="_ _3"> </span><span class="ff6 fs4">mpsc<span class="_ _3"> </span></span>或者<span class="_ _3"> </span><span class="ff6 fs4">spsc<span class="_ _3"> </span></span>或者<span class="_ _3"> </span><span class="ff6 fs4">oneshot<span class="_ _3"> </span></span>等类似的同步原语进</div><div class="t m0 x2 h6 y20a ff1 fs2 fc0 sc0 ls0 ws0">行控制，也可以使用这个<span class="ff5">crate:<span class="fc1">thread-control</span>:</span></div></div><div class="c x5 y165 w4 h13"><div class="t m0 x2 hc y20b ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><div class="c x5 yc5 w4 h13"><div class="t m0 x2 hc y20c ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><div class="c x5 y20d w4 h13"><div class="t m0 x2 hc y20e ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><a class="l" href="https://crates.io/crates/thread-control"><div class="d m1" style="border-style:none;position:absolute;left:202.578550px;bottom:342.994660px;width:77.287810px;height:15.757510px;background-color:rgba(255,255,255,0.000001);"></div></a></div><div class="pi" data-data='{"ctm":[1.000000,0.000000,0.000000,1.000000,0.000000,0.000000]}'></div></div>
<div id="pf10" class="pf w0 h0" data-page-no="10"><div class="pc pc10 w0 h0"><img class="bi x0 y0 w3 h7" alt="" src="bg10.png"/><div class="c x0 y19d w2 h2"><div class="t m0 x1 h3 y2 ff1 fs0 fc0 sc0 ls0 ws0">鸟窝<span class="ff2"> - https://github.com/smallnest/concurrency-programming-via-rust</span></div></div><div class="c x0 y20f w2 h2e"><div class="t m0 x4 hc y210 ff6 fs4 fc2 sc0 ls0 ws0">pub<span class="fc3"> </span>fn<span class="fc3"> <span class="fc4">control_thread<span class="fc5">()</span></span> <span class="fc5">{</span> </span></div><div class="t m0 x4 hc y211 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> <span class="fc5">(</span>flag<span class="fc5">,</span> control<span class="fc5">)</span> <span class="fc6">=</span> <span class="fc4">make_pair<span class="fc5">();</span></span> </div><div class="t m0 x4 hc y212 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> handle <span class="fc6">=</span> <span class="_ _2"> </span><span class="fc4">spawn<span class="fc5">(<span class="fc2">move</span></span></span> <span class="fc5">||</span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y213 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc2">while</span> flag<span class="fc5">.<span class="fc4">alive</span>()</span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y214 ff6 fs4 fc3 sc0 ls0 ws0">            <span class="_ _2"> </span><span class="fc4">sleep<span class="fc5">(</span>Duration<span class="fc5">::</span>from_millis<span class="fc5">(<span class="fc7">100</span>));</span></span> </div><div class="t m0 x4 hc y215 ff6 fs4 fc3 sc0 ls0 ws0">            <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;I&apos;m alive!&quot;</span>);</span></span> </div><div class="t m0 x4 hc y216 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc5">}</span> </div><div class="t m0 x4 hc y217 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">});</span> </div><div class="t m0 x4 hc y218 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="_ _2"> </span><span class="fc4">sleep<span class="fc5">(</span>Duration<span class="fc5">::</span>from_millis<span class="fc5">(<span class="fc7">100</span>));</span></span> </div><div class="t m0 x4 hc y219 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc7">assert_eq!<span class="fc5">(</span></span>control<span class="fc5">.<span class="fc4">is_done</span>(),</span> <span class="fc7">false<span class="fc5">);</span></span> </div><div class="t m0 x4 hc y21a ff6 fs4 fc3 sc0 ls0 ws0">    control<span class="fc5">.<span class="fc4">stop</span>();</span> <span class="fc9">// Also you can `control.interrupt()` it</span> </div><div class="t m0 x4 hc y21b ff6 fs4 fc3 sc0 ls0 ws0">    handle<span class="fc5">.<span class="fc4">join</span>().<span class="fc4">unwrap</span>();</span> </div><div class="t m0 x4 hc y21c ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc7">assert_eq!<span class="fc5">(</span></span>control<span class="fc5">.<span class="fc4">is_interrupted</span>(),</span> <span class="fc7">false<span class="fc5">);</span></span> </div><div class="t m0 x4 hc y21d ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc7">assert_eq!<span class="fc5">(</span></span>control<span class="fc5">.<span class="fc4">is_done</span>(),</span> <span class="fc7">true<span class="fc5">);</span></span> </div><div class="t m0 x4 hc y21e ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;This thread is stopped&quot;</span>)</span></span> </div><div class="t m0 x4 hc y21f ff6 fs4 fc5 sc0 ls0 ws0">}</div></div><div class="c x0 y19e w2 h28"><div class="t m0 x2 h6 y220 ff1 fs2 fc0 sc0 ls0 ws0">通过<span class="_ _3"> </span><span class="ff6 fs4">make_pair<span class="_ _3"> </span></span>生成一对对象<span class="_ _3"> </span><span class="ff6 fs4">flag,control<span class="_ _3"> </span></span><span class="ff5">,</span>就像破镜重圆的两块镜子心心相惜，或者更像处于纠</div><div class="t m0 x2 h6 y221 ff1 fs2 fc0 sc0 ls0 ws0">缠态的两个量子，其中一个量子的变化另外一个量子立马感知。这里<span class="_ _3"> </span><span class="ff6 fs4">control<span class="_ _3"> </span></span>交给父进程进行控</div><div class="t m0 x2 h6 y222 ff1 fs2 fc0 sc0 ls0 ws0">制，你可以调用<span class="_ _3"> </span><span class="ff6 fs4">stop<span class="_ _3"> </span></span>方法触发信号，这个时候<span class="ff5">flag.alive()</span>就会变为<span class="ff5">false</span>。如果子线程<span class="ff5">panickled,</span>可</div><div class="t m0 x2 h6 y223 ff1 fs2 fc0 sc0 ls0 ws0">以通过<span class="_ _3"> </span><span class="ff6 fs4">control.is_interrupted() == true<span class="_ _3"> </span></span>来判断。</div><div class="t m0 x2 ha y224 ff3 fs3 fc0 sc0 ls0 ws0">设置线程优先级</div><div class="t m0 x2 h6 y225 ff1 fs2 fc0 sc0 ls0 ws0">通过<span class="ff5">crate <span class="fc1">thread-priority</span></span>可以设置线程的优先级。</div><div class="t m0 x2 h6 y226 ff1 fs2 fc0 sc0 ls0 ws0">因为<span class="ff5">Rust</span>的线程都是纯的操作系统的优先级，现代的操作系统的线程都有优先级的概念，所以可</div><div class="t m0 x2 h6 y227 ff1 fs2 fc0 sc0 ls0 ws0">以通过系统调用等方式设置优先级，唯一一点不好的就是哦各个操作系统的平台的优先级的数字</div><div class="t m0 x2 h6 y228 ff1 fs2 fc0 sc0 ls0 ws0">和范围不一样。当前这个库支持以下的平台：</div><div class="t m0 x3 h2f y229 ff5 fs2 fc0 sc0 ls0 ws0">Linux</div><div class="t m0 x3 h2f y22a ff5 fs2 fc0 sc0 ls0 ws0">Android</div><div class="t m0 x3 h2f y22b ff5 fs2 fc0 sc0 ls0 ws0">DragonFly</div><div class="t m0 x3 h2f y22c ff5 fs2 fc0 sc0 ls0 ws0">FreeBSD</div><div class="t m0 x3 h2f y22d ff5 fs2 fc0 sc0 ls0 ws0">OpenBSD</div><div class="t m0 x3 h2f y22e ff5 fs2 fc0 sc0 ls0 ws0">NetBSD</div><div class="t m0 x3 h2f y22f ff5 fs2 fc0 sc0 ls0 ws0">macOS</div><div class="t m0 x3 h2f y230 ff5 fs2 fc0 sc0 ls0 ws0">Windows</div></div><div class="c x5 y137 w4 h13"><div class="t m0 x2 hc y231 ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><div class="c x7 yc3 w5 h13"><div class="t m0 x2 hc y232 ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><div class="c x8 yc5 w5 h13"><div class="t m0 x2 hc y233 ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><a class="l" href="https://crates.io/crates/thread-priority"><div class="d m1" style="border-style:none;position:absolute;left:95.276054px;bottom:330.988100px;width:77.287806px;height:15.758420px;background-color:rgba(255,255,255,0.000001);"></div></a></div><div class="pi" data-data='{"ctm":[1.000000,0.000000,0.000000,1.000000,0.000000,0.000000]}'></div></div>
<div id="pf11" class="pf w0 h0" data-page-no="11"><div class="pc pc11 w0 h0"><img class="bi x0 y0 w3 h7" alt="" src="bg11.png"/><div class="c x0 y19d w2 h2"><div class="t m0 x1 h3 y2 ff1 fs0 fc0 sc0 ls0 ws0">鸟窝<span class="ff2"> - https://github.com/smallnest/concurrency-programming-via-rust</span></div></div><div class="c x0 y19e w2 h28"><div class="t m0 x2 h6 y234 ff1 fs2 fc0 sc0 ls0 ws0">设置优先级的方法也很简单：</div></div><div class="c x0 y235 w2 h30"><div class="t m0 x4 hc y236 ff6 fs4 fc2 sc0 ls0 ws0">pub<span class="fc3"> </span>fn<span class="fc3"> <span class="fc4">start_thread_with_priority<span class="fc5">()</span></span> <span class="fc5">{</span> </span></div><div class="t m0 x4 hc y237 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> handle1 <span class="fc6">=</span> <span class="_ _2"> </span><span class="fc4">spawn<span class="fc5">(||</span></span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y238 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">assert!<span class="fc5">(<span class="fc4">set_current_thread_priority</span>(<span class="fc4">ThreadPriority</span>::<span class="fc4">Min</span>).<span class="fc4">is_ok</span>());</span></span> </div><div class="t m0 x4 hc y239 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;Hello from a thread5!&quot;</span>);</span></span></div><div class="t m0 x4 hc y23a ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">});</span> </div><div class="t m0 x4 hc y23b ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> handle2 <span class="fc6">=</span> <span class="_ _2"> </span><span class="fc4">spawn<span class="fc5">(||</span></span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y23c ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">assert!<span class="fc5">(<span class="fc4">set_current_thread_priority</span>(<span class="fc4">ThreadPriority</span>::<span class="fc4">Max</span>).<span class="fc4">is_ok</span>());</span></span> </div><div class="t m0 x4 hc y23d ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;Hello from a thread6!&quot;</span>);</span></span></div><div class="t m0 x4 hc y23e ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">});</span> </div><div class="t m0 x4 hc y23f ff6 fs4 fc3 sc0 ls0 ws0">    handle1<span class="fc5">.<span class="fc4">join</span>().<span class="fc4">unwrap</span>();</span> </div><div class="t m0 x4 hc y240 ff6 fs4 fc3 sc0 ls0 ws0">    handle2<span class="fc5">.<span class="fc4">join</span>().<span class="fc4">unwrap</span>();</span> </div><div class="t m0 x4 hc y241 ff6 fs4 fc5 sc0 ls0 ws0">}</div></div><div class="c x0 y19e w2 h28"><div class="t m0 x2 h6 y242 ff1 fs2 fc0 sc0 ls0 ws0">或者设置一个特定的值<span class="ff5">:</span></div></div><div class="c x0 y243 w2 h31"><div class="t m0 x4 hc y244 ff6 fs4 fc2 sc0 ls0 ws0">use<span class="fc3"> <span class="_ _b"> </span><span class="fc6">*<span class="fc5">;</span></span> </span></div><div class="t m0 x4 hc y245 ff6 fs4 fc2 sc0 ls0 ws0">use<span class="fc3"> <span class="_ _c"> </span><span class="fc4">TryInto<span class="fc5">;</span></span> </span></div><div class="t m0 x4 hc y246 ff6 fs4 fc9 sc0 ls0 ws0">// The lower the number the lower the priority.<span class="fc3"> </span></div><div class="t m0 x4 hc y247 ff6 fs4 fc7 sc0 ls0 ws0">assert!</div><div class="t m0 x4 hc y248 ff6 fs4 fc5 sc0 ls0 ws0">(<span class="fc4">set_current_thread_priority</span>(<span class="fc4">ThreadPriority</span>::<span class="fc4">Crossplatform</span>(<span class="fc7">0</span>.<span class="fc4">try_into</span>().<span class="fc4">unwrap</span>())).<span class="fc4">is_</span></div><div class="t m0 x4 hc y249 ff6 fs4 fc4 sc0 ls0 ws0">ok<span class="fc5">());<span class="fc3"> </span></span></div></div><div class="c x0 y19e w2 h28"><div class="t m0 x2 h6 y24a ff1 fs2 fc0 sc0 ls0 ws0">你还可以设置特定平台的优先级值：</div></div><div class="c x0 y24b w2 h32"><div class="t m0 x4 hc y24c ff6 fs4 fc2 sc0 ls0 ws0">use<span class="fc3"> <span class="_ _b"> </span><span class="fc6">*<span class="fc5">;</span></span> </span></div><div class="t m0 x4 hc y24d ff6 fs4 fc2 sc0 ls0 ws0">fn<span class="fc3"> <span class="fc4">main<span class="fc5">()</span></span> <span class="fc5">{</span> </span></div><div class="t m0 x4 hc y24e ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc9">// The lower the number the lower the priority.</span> </div><div class="t m0 x4 hc y24f ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc7">assert!</span></div><div class="t m0 x4 hc y250 ff6 fs4 fc5 sc0 ls0 ws0">(<span class="fc4">set_current_thread_priority</span>(<span class="fc4">ThreadPriority</span>::<span class="fc4">Os</span>(<span class="fc4">WinAPIThreadPriority</span>::<span class="fc4">Lowest</span>.<span class="fc4">into</span>())).</div><div class="t m0 x4 hc y251 ff6 fs4 fc4 sc0 ls0 ws0">is_ok<span class="fc5">());<span class="fc3"> </span></span></div><div class="t m0 x4 hc y252 ff6 fs4 fc5 sc0 ls0 ws0">}</div></div><div class="c x0 y19e w2 h28"><div class="t m0 x2 h6 y253 ff1 fs2 fc0 sc0 ls0 ws0">它还提供了一个<span class="ff5">ThreadBuilder,</span>类似标准库的<span class="ff5">ThreadBuilder,</span>只不过增加设置优先级的能力：</div></div><div class="c x6 y78 w5 h13"><div class="t m0 x2 hc y254 ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><div class="c x6 y255 w5 h13"><div class="t m0 x2 hc y256 ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><div class="c x8 y257 wd h13"><div class="t m0 x2 hc y258 ff6 fs4 fc3 sc0 ls0 ws0">thread_priority<span class="fc5">::</span></div></div><div class="c x8 y259 we h13"><div class="t m0 x2 hc y25a ff6 fs4 fc3 sc0 ls0 ws0">std<span class="fc5">::</span>convert<span class="fc5">::</span></div></div><div class="c x8 y25b wd h13"><div class="t m0 x2 hc y25c ff6 fs4 fc3 sc0 ls0 ws0">thread_priority<span class="fc5">::</span></div></div></div><div class="pi" data-data='{"ctm":[1.000000,0.000000,0.000000,1.000000,0.000000,0.000000]}'></div></div>
<div id="pf12" class="pf w0 h0" data-page-no="12"><div class="pc pc12 w0 h0"><img class="bi x0 y0 w3 h7" alt="" src="bg12.png"/><div class="c x0 y19d w2 h2"><div class="t m0 x1 h3 y2 ff1 fs0 fc0 sc0 ls0 ws0">鸟窝<span class="ff2"> - https://github.com/smallnest/concurrency-programming-via-rust</span></div></div><div class="c x0 y25d w2 h33"><div class="t m0 x4 hc y25e ff6 fs4 fc2 sc0 ls0 ws0">use<span class="fc3"> <span class="_ _b"> </span><span class="fc6">*<span class="fc5">;</span></span> </span></div><div class="t m0 x4 hc y25f ff6 fs4 fc2 sc0 ls0 ws0">let<span class="fc3"> thread <span class="fc6">=</span> <span class="fc4">ThreadBuilder<span class="fc5">::</span>default<span class="fc5">()</span></span> </span></div><div class="t m0 x4 hc y260 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">.<span class="fc4">name</span>(<span class="fc8">&quot;MyThread&quot;</span>)</span> </div><div class="t m0 x4 hc y261 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">.<span class="fc4">priority</span>(<span class="fc4">ThreadPriority</span>::<span class="fc4">Max</span>)</span> </div><div class="t m0 x4 hc y262 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">.<span class="fc4">spawn</span>(|</span>result<span class="fc5">|</span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y263 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc9">// This is printed out from within the spawned thread.</span> </div><div class="t m0 x4 hc y264 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;Set priority result: {:?}&quot;</span>,</span></span> result<span class="fc5">);</span> </div><div class="t m0 x4 hc y265 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">assert!<span class="fc5">(</span></span>result<span class="fc5">.<span class="fc4">is_ok</span>());</span> </div><div class="t m0 x4 hc y266 ff6 fs4 fc5 sc0 ls0 ws0">}).<span class="fc4">unwrap</span>();<span class="fc3"> </span></div><div class="t m0 x4 hc y267 ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">.<span class="fc4">join</span>();</span></div></div><div class="c x0 y19e w2 h28"><div class="t m0 x2 h6 y268 ff1 fs2 fc0 sc0 ls0 ws0">或者使用<span class="_ _3"> </span><span class="ff6 fs4">thread_priority::ThreadBuilderExt;<span class="_ _3"> </span></span>扩展标准库的<span class="ff5">ThreadBuilder</span>支持设置优先级。</div><div class="t m0 x2 h6 y269 ff1 fs2 fc0 sc0 ls0 ws0">你还可以通过<span class="_ _3"> </span><span class="ff6 fs4">get_priority<span class="_ _3"> </span></span>获取当前线程的优先级：</div></div><div class="c x0 y26a w2 h34"><div class="t m0 x4 hc y26b ff6 fs4 fc2 sc0 ls0 ws0">use<span class="fc3"> <span class="_ _b"> </span><span class="fc6">*<span class="fc5">;</span></span> </span></div><div class="t m0 x4 hc y26c ff6 fs4 fc7 sc0 ls0 ws0">assert!<span class="fc5">(<span class="_ _8"> </span><span class="fc4">current</span>().<span class="fc4">get_priority</span>().<span class="fc4">is_ok</span>());<span class="fc3"> </span></span></div><div class="t m0 x4 hc y26d ff6 fs4 fc7 sc0 ls0 ws0">println!<span class="fc5">(<span class="fc8">&quot;This thread&apos;s native id is: {:?}&quot;</span>,<span class="fc3"> <span class="_ _8"> </span><span class="fc4">current</span></span>().<span class="fc4">get_native_id</span>());</span></div></div><div class="c x0 y19e w2 h28"><div class="t m0 x2 ha y26e ff3 fs3 fc0 sc0 ls0 ws0">设置<span class="ff4"> affinity</span></div><div class="t m0 x2 h6 y26f ff1 fs2 fc0 sc0 ls0 ws0">你可以将线程绑定在一个核上或者几个核上。有个较老的<span class="ff5">crate <span class="fc1">core_affinity</span>,</span>但是它只能将线程绑</div><div class="t m0 x2 h6 y270 ff1 fs2 fc0 sc0 ls0 ws0">定到一个核上，如果要绑定到多个核上，可以使用<span class="ff5">crate <span class="fc1">affinity</span>:</span></div></div><div class="c x0 y271 w2 h22"><div class="t m0 x4 hc y272 ff6 fs4 fc8 sc0 ls0 ws0">#[cfg(not(target_os = &quot;macos&quot;))]<span class="fc3"> </span></div><div class="t m0 x4 hc y273 ff6 fs4 fc2 sc0 ls0 ws0">pub<span class="fc3"> </span>fn<span class="fc3"> <span class="fc4">use_affinity<span class="fc5">()</span></span> <span class="fc5">{</span> </span></div><div class="t m0 x4 hc y274 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc9">// Select every second core</span> </div><div class="t m0 x4 hc y275 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> cores<span class="fc5">:</span> <span class="fc4">Vec<span class="fc6">&lt;<span class="fc2">usize</span>&gt;</span></span> <span class="fc6">=</span> <span class="fc5">(<span class="fc7">0</span>..<span class="fc4">get_core_num</span>()).<span class="fc4">step_by</span>(<span class="fc7">2</span>).<span class="fc4">collect</span>();</span> </div><div class="t m0 x4 hc y276 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;Binding thread to cores : {:?}&quot;</span>,</span></span> <span class="fc6">&amp;</span>cores<span class="fc5">);</span> </div><div class="t m0 x4 hc y277 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="_ _7"> </span><span class="fc4">set_thread_affinity<span class="fc5">(<span class="fc6">&amp;</span></span></span>cores<span class="fc5">).<span class="fc4">unwrap</span>();</span> </div><div class="t m0 x4 hc y278 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc7">println!<span class="fc5">(</span></span> </div><div class="t m0 x4 hc y279 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc8">&quot;Current thread affinity : {:?}&quot;<span class="fc5">,</span></span> </div><div class="t m0 x4 hc y27a ff6 fs4 fc3 sc0 ls0 ws0">        <span class="_ _7"> </span><span class="fc4">get_thread_affinity<span class="fc5">().</span>unwrap<span class="fc5">()</span></span> </div><div class="t m0 x4 hc y27b ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">);</span> </div><div class="t m0 x4 hc y27c ff6 fs4 fc5 sc0 ls0 ws0">}</div></div><div class="c x0 y19e w2 h28"><div class="t m0 x2 h6 y27d ff1 fs2 fc0 sc0 ls0 ws0">不过它当前不支持<span class="ff5">MacOS</span>，所以在苹果本上还没办法使用。上面这个例子我们把当前线程绑定到</div><div class="t m0 x2 h6 y27e ff1 fs2 fc0 sc0 ls0 ws0">偶数的核上。</div></div><div class="c x8 y105 wd h13"><div class="t m0 x2 hc y27f ff6 fs4 fc3 sc0 ls0 ws0">thread_priority<span class="fc5">::</span></div></div><div class="c x8 y280 wd h13"><div class="t m0 x2 hc y281 ff6 fs4 fc3 sc0 ls0 ws0">thread_priority<span class="fc5">::</span></div></div><div class="c x10 y282 wf h13"><div class="t m0 x2 hc y283 ff6 fs4 fc3 sc0 ls0 ws0">std<span class="fc5">::</span>thread<span class="fc5">::</span></div></div><div class="c x13 y257 wf h13"><div class="t m0 x2 hc y284 ff6 fs4 fc3 sc0 ls0 ws0">std<span class="fc5">::</span>thread<span class="fc5">::</span></div></div><div class="c x8 y285 w9 hf"><div class="t m0 x2 hc y286 ff6 fs4 fc3 sc0 ls0 ws0">affinity<span class="fc5">::</span></div></div><div class="c x10 y287 w9 hf"><div class="t m0 x2 hc y288 ff6 fs4 fc3 sc0 ls0 ws0">affinity<span class="fc5">::</span></div></div><a class="l" href="https://crates.io/crates/core_affinity"><div class="d m1" style="border-style:none;position:absolute;left:371.411130px;bottom:376.009670px;width:64.531590px;height:15.758430px;background-color:rgba(255,255,255,0.000001);"></div></a><a class="l" href="https://crates.io/crates/affinity"><div class="d m1" style="border-style:none;position:absolute;left:335.393520px;bottom:358.001220px;width:36.017610px;height:15.757510px;background-color:rgba(255,255,255,0.000001);"></div></a></div><div class="pi" data-data='{"ctm":[1.000000,0.000000,0.000000,1.000000,0.000000,0.000000]}'></div></div>
<div id="pf13" class="pf w0 h0" data-page-no="13"><div class="pc pc13 w0 h0"><img class="bi x0 y0 w3 h7" alt="" src="bg13.png"/><div class="c x0 yc7 w2 h2"><div class="t m0 x1 h3 y2 ff1 fs0 fc0 sc0 ls0 ws0">鸟窝<span class="ff2"> - https://github.com/smallnest/concurrency-programming-via-rust</span></div></div><div class="c x0 y1d6 w2 h2b"><div class="t m0 x2 h6 y289 ff1 fs2 fc0 sc0 ls0 ws0">绑核是在极端情况提升性能的有效手段之一，将某几个核只给我们的应用使用，可以让这些核专</div><div class="t m0 x2 h6 y28a ff1 fs2 fc0 sc0 ls0 ws0">门提供给我们的业务服务，既提供了<span class="ff5">CPU</span>资源隔离，还提升了性能。</div><div class="t m0 x2 h6 y28b ff1 fs2 fc0 sc0 ls0 ws0">尽量把线程绑定在同一个<span class="ff5">NUMA</span>节点的核上。</div><div class="t m0 x2 h12 y28c ff4 fs3 fc0 sc0 ls0 ws0">P<span class="_ _4"></span>anic</div><div class="t m0 x2 h6 y28d ff5 fs2 fc0 sc0 ls0 ws0">Rust<span class="ff1">中致命的逻辑错误会导致线程</span> panic, <span class="ff1">出现</span>panic<span class="ff1">是线程会执行栈回退，运行解构器以及释放拥</span></div><div class="t m0 x2 h6 y28e ff1 fs2 fc0 sc0 ls0 ws0">有的资源等等。<span class="ff5">Rust</span>可以使用<span class="_ _3"> </span><span class="ff6 fs4">catch_unwind<span class="_ _3"> </span></span>实现类似<span class="_ _3"> </span><span class="ff6 fs4">try/catch<span class="_ _3"> </span></span>捕获<span class="ff5">panic</span>的功能，或者</div><div class="t m0 xa h6 y28f ff6 fs4 fc0 sc0 ls0 ws0">resume_unwind<span class="_ _3"> </span><span class="ff1 fs2">继续执行。如果<span class="ff5">panic</span>没有被捕获，那么线程就会退出，通过<span class="ff5">JoinHandle</span>可以检查</span></div><div class="t m0 x2 h6 y290 ff1 fs2 fc0 sc0 ls0 ws0">这个错误，如下面的代码：</div></div><div class="c x0 y291 w2 h35"><div class="t m0 x4 hc y292 ff6 fs4 fc2 sc0 ls0 ws0">pub<span class="fc3"> </span>fn<span class="fc3"> <span class="fc4">panic_example<span class="fc5">()</span></span> <span class="fc5">{</span> </span></div><div class="t m0 x4 hc y293 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;Hello, world!&quot;</span>);</span></span> </div><div class="t m0 x4 hc y294 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> h <span class="fc6">=</span> <span class="_ _8"> </span><span class="fc4">spawn<span class="fc5">(||</span></span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y295 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="_ _8"> </span><span class="fc4">sleep<span class="fc5">(<span class="_ _d"> </span></span>Duration<span class="fc5">::</span>from_millis<span class="fc5">(<span class="fc7">1000</span>));</span></span> </div><div class="t m0 x4 hc y296 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">panic!<span class="fc5">(<span class="fc8">&quot;boom&quot;</span>);</span></span> </div><div class="t m0 x4 hc y297 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">});</span> </div><div class="t m0 x4 hc y298 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> r <span class="fc6">=</span> h<span class="fc5">.<span class="fc4">join</span>();</span> </div><div class="t m0 x4 hc y299 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">match</span> r <span class="fc5">{</span> </div><div class="t m0 x4 hc y29a ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc4">Ok<span class="fc5">(</span></span>r<span class="fc5">)</span> <span class="fc6">=&gt;</span> <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;All is well! {:?}&quot;</span>,</span></span> r<span class="fc5">),</span> </div><div class="t m0 x4 hc y29b ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc4">Err<span class="fc5">(</span></span>e<span class="fc5">)</span> <span class="fc6">=&gt;</span> <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;Got an error! {:?}&quot;</span>,</span></span> e<span class="fc5">),</span> </div><div class="t m0 x4 hc y29c ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">}</span> </div><div class="t m0 x4 hc y29d ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;Exiting main!&quot;</span>)</span></span> </div><div class="t m0 x4 hc y29e ff6 fs4 fc5 sc0 ls0 ws0">}</div></div><div class="c x0 y1d6 w2 h2b"><div class="t m0 x2 h6 y29f ff1 fs2 fc0 sc0 ls0 ws0">如果被捕获，外部的<span class="ff5">handle</span>是检查不到这个<span class="ff5">panic</span>的：</div></div><div class="c x7 y2a0 wf he"><div class="t m0 x2 hc y2a1 ff6 fs4 fc3 sc0 ls0 ws0">std<span class="fc5">::</span>thread<span class="fc5">::</span></div></div><div class="c x10 y2a2 wf hf"><div class="t m0 x2 hc y2a3 ff6 fs4 fc3 sc0 ls0 ws0">std<span class="fc5">::</span>thread<span class="fc5">::</span></div></div><div class="c x14 y2a2 w10 hf"><div class="t m0 x2 hc y2a3 ff6 fs4 fc3 sc0 ls0 ws0">std<span class="fc5">::</span>time<span class="fc5">::</span></div></div></div><div class="pi" data-data='{"ctm":[1.000000,0.000000,0.000000,1.000000,0.000000,0.000000]}'></div></div>
<div id="pf14" class="pf w0 h0" data-page-no="14"><div class="pc pc14 w0 h0"><img class="bi x0 y0 w3 h7" alt="" src="bg14.png"/><div class="c x0 y19d w2 h2"><div class="t m0 x1 h3 y2 ff1 fs0 fc0 sc0 ls0 ws0">鸟窝<span class="ff2"> - https://github.com/smallnest/concurrency-programming-via-rust</span></div></div><div class="c x0 y2a4 w2 h36"><div class="t m0 x4 hc y2a5 ff6 fs4 fc2 sc0 ls0 ws0">pub<span class="fc3"> </span>fn<span class="fc3"> <span class="fc4">panic_caught_example<span class="fc5">()</span></span> <span class="fc5">{</span> </span></div><div class="t m0 x4 hc y2a6 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;Hello, panic_caught_example !&quot;</span>);</span></span> </div><div class="t m0 x4 hc y2a7 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> h <span class="fc6">=</span> <span class="_ _8"> </span><span class="fc4">spawn<span class="fc5">(||</span></span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y26 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="_ _8"> </span><span class="fc4">sleep<span class="fc5">(<span class="_ _d"> </span></span>Duration<span class="fc5">::</span>from_millis<span class="fc5">(<span class="fc7">1000</span>));</span></span> </div><div class="t m0 x4 hc y2a8 ff6 fs4 fc3 sc0 ls0 ws0">       <span class="fc2">let</span> result <span class="fc6">=</span> <span class="_ _e"> </span><span class="fc4">catch_unwind<span class="fc5">(||</span></span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y2a9 ff6 fs4 fc3 sc0 ls0 ws0">            <span class="fc7">panic!<span class="fc5">(<span class="fc8">&quot;boom&quot;</span>);</span></span> </div><div class="t m0 x4 hc y2aa ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc5">});</span> </div><div class="t m0 x4 hc y2ab ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;panic caught, result = {}&quot;</span>,</span></span> result<span class="fc5">.<span class="fc4">is_err</span>());</span> <span class="fc9">// true</span> </div><div class="t m0 x4 hc y2ac ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">});</span> </div><div class="t m0 x4 hc y2ad ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> r <span class="fc6">=</span> h<span class="fc5">.<span class="fc4">join</span>();</span> </div><div class="t m0 x4 hc y2ae ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">match</span> r <span class="fc5">{</span> </div><div class="t m0 x4 hc y2af ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc4">Ok<span class="fc5">(</span></span>r<span class="fc5">)</span> <span class="fc6">=&gt;</span> <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;All is well! {:?}&quot;</span>,</span></span> r<span class="fc5">),</span> <span class="fc9">// here</span> </div><div class="t m0 x4 hc y2b0 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc4">Err<span class="fc5">(</span></span>e<span class="fc5">)</span> <span class="fc6">=&gt;</span> <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;Got an error! {:?}&quot;</span>,</span></span> e<span class="fc5">),</span> </div><div class="t m0 x4 hc y2b1 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">}</span> </div><div class="t m0 x4 hc y2b2 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;Exiting main!&quot;</span>)</span></span> </div><div class="t m0 x4 hc y2b3 ff6 fs4 fc5 sc0 ls0 ws0">}</div></div><div class="c x0 y19e w2 h28"><div class="t m0 x2 h6 y2b4 ff1 fs2 fc0 sc0 ls0 ws0">通过<span class="ff5">scope</span>生成的<span class="ff5">scope thread</span>，任何一个线程<span class="ff5">panic,</span>如果未被捕获，那么<span class="ff5">scope</span>返回是就会返回这</div><div class="t m0 x2 h6 y2b5 ff1 fs2 fc0 sc0 ls0 ws0">个错误。</div><div class="t m0 x2 h12 y2b6 ff4 fs3 fc0 sc0 ls0 ws0">crossbeam scoped thr<span class="_ _1"></span>ead</div><div class="t m0 x2 h6 y2b7 ff5 fs2 fc0 sc0 ls0 ws0">crossbeam <span class="ff1">也提供了创建了</span>scoped thread<span class="ff1">的功能，和标准库的</span>scope<span class="ff1">功能类似，但是它创建的</span></div><div class="t m0 x2 h6 y2b8 ff5 fs2 fc0 sc0 ls0 ws0">scoped thread<span class="ff1">可以继续创建</span>scoped thread:</div></div><div class="c x7 y165 wf h13"><div class="t m0 x2 hc y2b9 ff6 fs4 fc3 sc0 ls0 ws0">std<span class="fc5">::</span>thread<span class="fc5">::</span></div></div><div class="c x10 yc3 wf h13"><div class="t m0 x2 hc y2ba ff6 fs4 fc3 sc0 ls0 ws0">std<span class="fc5">::</span>thread<span class="fc5">::</span></div></div><div class="c x14 yc3 w10 h13"><div class="t m0 x2 hc y2ba ff6 fs4 fc3 sc0 ls0 ws0">std<span class="fc5">::</span>time<span class="fc5">::</span></div></div><div class="c x15 y2bb w11 h13"><div class="t m0 x2 hc y2bc ff6 fs4 fc3 sc0 ls0 ws0">std<span class="fc5">::</span>panic<span class="fc5">::</span></div></div></div><div class="pi" data-data='{"ctm":[1.000000,0.000000,0.000000,1.000000,0.000000,0.000000]}'></div></div>
<div id="pf15" class="pf w0 h0" data-page-no="15"><div class="pc pc15 w0 h0"><img class="bi x0 y0 w3 h7" alt="" src="bg15.png"/><div class="c x0 y19d w2 h2"><div class="t m0 x1 h3 y2 ff1 fs0 fc0 sc0 ls0 ws0">鸟窝<span class="ff2"> - https://github.com/smallnest/concurrency-programming-via-rust</span></div></div><div class="c x0 y2bd w2 h37"><div class="t m0 x4 hc y2be ff6 fs4 fc2 sc0 ls0 ws0">pub<span class="fc3"> </span>fn<span class="fc3"> <span class="fc4">crossbeam_scope<span class="fc5">()</span></span> <span class="fc5">{</span> </span></div><div class="t m0 x4 hc y2bf ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> <span class="fc2">mut</span> a <span class="fc6">=</span> <span class="fc7">vec!<span class="fc5">[</span>1<span class="fc5">,</span></span> <span class="fc7">2<span class="fc5">,</span></span> <span class="fc7">3<span class="fc5">];</span></span> </div><div class="t m0 x4 hc y2c0 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> <span class="fc2">mut</span> x <span class="fc6">=</span> <span class="fc7">0<span class="fc5">;</span></span> </div><div class="t m0 x4 hc y2c1 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="_ _f"> </span><span class="fc4">scope<span class="fc5">(|</span></span>s<span class="fc5">|</span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y2c2 ff6 fs4 fc3 sc0 ls0 ws0">        s<span class="fc5">.<span class="fc4">spawn</span>(|</span>_<span class="fc5">|</span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y2c3 ff6 fs4 fc3 sc0 ls0 ws0">            <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;hello from the first crossbeam scoped thread&quot;</span>);</span></span> </div><div class="t m0 x4 hc y2c4 ff6 fs4 fc3 sc0 ls0 ws0">            <span class="fc7">dbg!<span class="fc5">(<span class="fc6">&amp;</span></span></span>a<span class="fc5">);</span> </div><div class="t m0 x4 hc y2c5 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc5">});</span> </div><div class="t m0 x4 hc y2c6 ff6 fs4 fc3 sc0 ls0 ws0">        s<span class="fc5">.<span class="fc4">spawn</span>(|</span>_<span class="fc5">|</span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y2c7 ff6 fs4 fc3 sc0 ls0 ws0">            <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;hello from the second crossbeam scoped thread&quot;</span>);</span></span> </div><div class="t m0 x4 hc y2c8 ff6 fs4 fc3 sc0 ls0 ws0">            x <span class="fc6">+=</span> a<span class="fc5">[<span class="fc7">0</span>]</span> <span class="fc6">+</span> a<span class="fc5">[<span class="fc7">2</span>];</span> </div><div class="t m0 x4 hc y2c9 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc5">});</span> </div><div class="t m0 x4 hc y2ca ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;hello from the main thread&quot;</span>);</span></span> </div><div class="t m0 x4 hc y2cb ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">})</span> </div><div class="t m0 x4 hc y2cc ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">.<span class="fc4">unwrap</span>();</span> </div><div class="t m0 x4 hc y2cd ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc9">// After the scope, we can modify and access our variables again:</span> </div><div class="t m0 x4 hc y2ce ff6 fs4 fc3 sc0 ls0 ws0">    a<span class="fc5">.<span class="fc4">push</span>(<span class="fc7">4</span>);</span> </div><div class="t m0 x4 hc y2cf ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc7">assert_eq!<span class="fc5">(</span></span>x<span class="fc5">,</span> a<span class="fc5">.<span class="fc4">len</span>());</span> </div><div class="t m0 x4 hc y2d0 ff6 fs4 fc5 sc0 ls0 ws0">}</div></div><div class="c x0 y19e w2 h28"><div class="t m0 x2 h6 y2d1 ff1 fs2 fc0 sc0 ls0 ws0">这里我们创建了两个子线程，子线程在<span class="ff5">spawn</span>的时候，传递了一个<span class="ff5">scope</span>值的，利用这个<span class="ff5">scope</span>值</div><div class="t m0 x2 h6 y2d2 ff1 fs2 fc0 sc0 ls0 ws0">还可以在子线程中创建孙线程。</div><div class="t m0 x2 h12 y2d3 ff4 fs3 fc0 sc0 ls0 ws0">Rayon scoped thr<span class="_ _1"></span>ead</div><div class="t m0 x2 h6 y2d4 ff5 fs2 fc1 sc0 ls0 ws0">rayon<span class="ff1 fc0">也提供了和<span class="ff5">crossbeam</span>类似的机制，用来创建孙线程，子子孙孙线程：</span></div></div><div class="c x8 yc3 w12 h13"><div class="t m0 x2 hc y2d5 ff6 fs4 fc3 sc0 ls0 ws0">crossbeam_thread<span class="fc5">::</span></div></div><a class="l" href="https://docs.rs/rayon/1.5.3/rayon/fn.scope.html"><div class="d m1" style="border-style:none;position:absolute;left:42.000000px;bottom:338.491850px;width:30.014687px;height:15.758420px;background-color:rgba(255,255,255,0.000001);"></div></a></div><div class="pi" data-data='{"ctm":[1.000000,0.000000,0.000000,1.000000,0.000000,0.000000]}'></div></div>
<div id="pf16" class="pf w0 h0" data-page-no="16"><div class="pc pc16 w0 h0"><img class="bi x0 y0 w3 h7" alt="" src="bg16.png"/><div class="c x0 y19d w2 h2"><div class="t m0 x1 h3 y2 ff1 fs0 fc0 sc0 ls0 ws0">鸟窝<span class="ff2"> - https://github.com/smallnest/concurrency-programming-via-rust</span></div></div><div class="c x0 y2a4 w2 h36"><div class="t m0 x4 hc y2d6 ff6 fs4 fc2 sc0 ls0 ws0">pub<span class="fc3"> </span>fn<span class="fc3"> <span class="fc4">rayon_scope<span class="fc5">()</span></span> <span class="fc5">{</span> </span></div><div class="t m0 x4 hc y2d7 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> <span class="fc2">mut</span> a <span class="fc6">=</span> <span class="fc7">vec!<span class="fc5">[</span>1<span class="fc5">,</span></span> <span class="fc7">2<span class="fc5">,</span></span> <span class="fc7">3<span class="fc5">];</span></span> </div><div class="t m0 x4 hc y2d8 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> <span class="fc2">mut</span> x <span class="fc6">=</span> <span class="fc7">0<span class="fc5">;</span></span> </div><div class="t m0 x4 hc y2d9 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="_ _10"> </span><span class="fc4">scope<span class="fc5">(|</span></span>s<span class="fc5">|</span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y2da ff6 fs4 fc3 sc0 ls0 ws0">        s<span class="fc5">.<span class="fc4">spawn</span>(|</span>_<span class="fc5">|</span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y2db ff6 fs4 fc3 sc0 ls0 ws0">            <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;hello from the first rayon scoped thread&quot;</span>);</span></span> </div><div class="t m0 x4 hc y2dc ff6 fs4 fc3 sc0 ls0 ws0">            <span class="fc7">dbg!<span class="fc5">(<span class="fc6">&amp;</span></span></span>a<span class="fc5">);</span> </div><div class="t m0 x4 hc y2dd ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc5">});</span> </div><div class="t m0 x4 hc y2de ff6 fs4 fc3 sc0 ls0 ws0">        s<span class="fc5">.<span class="fc4">spawn</span>(|</span>_<span class="fc5">|</span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y2df ff6 fs4 fc3 sc0 ls0 ws0">            <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;hello from the second rayon scoped thread&quot;</span>);</span></span> </div><div class="t m0 x4 hc y2e0 ff6 fs4 fc3 sc0 ls0 ws0">            x <span class="fc6">+=</span> a<span class="fc5">[<span class="fc7">0</span>]</span> <span class="fc6">+</span> a<span class="fc5">[<span class="fc7">2</span>];</span> </div><div class="t m0 x4 hc y2e1 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc5">});</span> </div><div class="t m0 x4 hc y2e2 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;hello from the main thread&quot;</span>);</span></span> </div><div class="t m0 x4 hc y2e3 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">});</span> </div><div class="t m0 x4 hc y2e4 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc9">// After the scope, we can modify and access our variables again:</span> </div><div class="t m0 x4 hc y2e5 ff6 fs4 fc3 sc0 ls0 ws0">    a<span class="fc5">.<span class="fc4">push</span>(<span class="fc7">4</span>);</span> </div><div class="t m0 x4 hc y2e6 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc7">assert_eq!<span class="fc5">(</span></span>x<span class="fc5">,</span> a<span class="fc5">.<span class="fc4">len</span>());</span> </div><div class="t m0 x4 hc y2e7 ff6 fs4 fc5 sc0 ls0 ws0">}</div></div><div class="c x0 y19e w2 h28"><div class="t m0 x2 h6 y2e8 ff1 fs2 fc0 sc0 ls0 ws0">同时<span class="ff5">, rayon</span>还提供了另外一个功能<span class="ff5">: fifo</span>的<span class="ff5">scope thread</span>。</div><div class="t m0 x2 h6 y2e9 ff1 fs2 fc0 sc0 ls0 ws0">比如下面一段<span class="ff5">scope_fifo</span>代码：</div></div><div class="c x0 y2ea w2 h38"><div class="t m0 x16 hc y2eb ff6 fs4 fc4 sc0 ls0 ws0">scope_fifo<span class="fc5">(|<span class="fc3">s</span>|<span class="fc3"> </span>{<span class="fc3"> </span></span></div><div class="t m0 x4 hc y2ec ff6 fs4 fc3 sc0 ls0 ws0">    s<span class="fc5">.<span class="fc4">spawn_fifo</span>(|</span>s<span class="fc5">|</span> <span class="fc5">{</span> <span class="fc9">// task s.1</span> </div><div class="t m0 x4 hc y2ed ff6 fs4 fc3 sc0 ls0 ws0">        s<span class="fc5">.<span class="fc4">spawn_fifo</span>(|</span>s<span class="fc5">|</span> <span class="fc5">{</span> <span class="fc9">// task s.1.1</span></div><div class="t m0 x4 hc y2ee ff6 fs4 fc3 sc0 ls0 ws0">            <span class="_ _10"> </span><span class="fc4">scope_fifo<span class="fc5">(|</span></span>t<span class="fc5">|</span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y2ef ff6 fs4 fc3 sc0 ls0 ws0">                t<span class="fc5">.<span class="fc4">spawn_fifo</span>(|</span>_<span class="fc5">|</span> <span class="fc5">());</span> <span class="fc9">// task t.1</span> </div><div class="t m0 x4 hc y2f0 ff6 fs4 fc3 sc0 ls0 ws0">                t<span class="fc5">.<span class="fc4">spawn_fifo</span>(|</span>_<span class="fc5">|</span> <span class="fc5">());</span> <span class="fc9">// task t.2</span> </div><div class="t m0 x4 hc y2f1 ff6 fs4 fc3 sc0 ls0 ws0">            <span class="fc5">});</span> </div><div class="t m0 x4 hc y2f2 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc5">});</span> </div><div class="t m0 x4 hc y2f3 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">});</span> </div><div class="t m0 x4 hc y2f4 ff6 fs4 fc3 sc0 ls0 ws0">    s<span class="fc5">.<span class="fc4">spawn_fifo</span>(|</span>s<span class="fc5">|</span> <span class="fc5">{</span> <span class="fc9">// task s.2</span> </div><div class="t m0 x4 hc y2f5 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">});</span> </div><div class="t m0 x4 hc y2f6 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc9">// point mid</span> </div><div class="t m0 x4 hc y2f7 ff6 fs4 fc5 sc0 ls0 ws0">});<span class="fc3"> </span></div><div class="t m0 x4 hc y2f8 ff6 fs4 fc9 sc0 ls0 ws0">// point end</div></div><div class="c x0 y19e w2 h28"><div class="t m0 x2 h6 y2f9 ff1 fs2 fc0 sc0 ls0 ws0">它的线程并发执行的顺序类似下面的顺序：</div></div><div class="c x8 yc3 w13 h13"><div class="t m0 x2 hc y2fa ff6 fs4 fc3 sc0 ls0 ws0">rayon<span class="fc5">::</span></div></div><div class="c x17 ye2 w14 h13"><div class="t m0 x2 hc y2fb ff6 fs4 fc3 sc0 ls0 ws0">rayon<span class="fc5">::</span></div></div><div class="c x7 y2fc w13 h13"><div class="t m0 x2 hc y2fd ff6 fs4 fc3 sc0 ls0 ws0">rayon<span class="fc5">::</span></div></div></div><div class="pi" data-data='{"ctm":[1.000000,0.000000,0.000000,1.000000,0.000000,0.000000]}'></div></div>
<div id="pf17" class="pf w0 h0" data-page-no="17"><div class="pc pc17 w0 h0"><img class="bi x0 y0 w3 h1" alt="" src="bg17.png"/><div class="c x0 yc7 w2 h2"><div class="t m0 x1 h3 y2 ff1 fs0 fc0 sc0 ls0 ws0">鸟窝<span class="ff2"> - https://github.com/smallnest/concurrency-programming-via-rust</span></div></div><div class="c x0 y2fe w2 h39"><div class="t m0 x4 hc y2ff ff6 fs4 fc6 sc0 ls0 ws0">|<span class="fc3"> <span class="fc5">(</span>start<span class="fc5">)</span> </span></div><div class="t m0 x4 hc y300 ff6 fs4 fc6 sc0 ls0 ws0">|<span class="fc3"> </span></div><div class="t m0 x4 hc y301 ff6 fs4 fc6 sc0 ls0 ws0">|<span class="fc3"> <span class="fc5">(</span>FIFO scope <span class="fcb">`s`</span> created<span class="fc5">)</span> </span></div><div class="t m0 x4 hc y302 ff6 fs4 fc3 sc0 ls0 ws0">+--------------------+ <span class="fc5">(</span>task s.1<span class="fc5">)</span> </div><div class="t m0 x4 hc y303 ff6 fs4 fc3 sc0 ls0 ws0">+-------+ <span class="fc5">(</span>task s.2<span class="fc5">)</span> <span class="fc6">|</span> </div><div class="t m0 x4 hc y304 ff6 fs4 fc6 sc0 ls0 ws0">|<span class="fc3">       </span>|<span class="fc3">            +---+ <span class="fc5">(</span>task s.1.1<span class="fc5">)</span> </span></div><div class="t m0 x4 hc y305 ff6 fs4 fc6 sc0 ls0 ws0">|<span class="fc3">       </span>|<span class="fc3">            </span>|<span class="fc3">   </span>|<span class="fc3"> </span></div><div class="t m0 x4 hc y306 ff6 fs4 fc6 sc0 ls0 ws0">|<span class="fc3">       </span>|<span class="fc3">            </span>|<span class="fc3">   </span>|<span class="fc3"> <span class="fc5">(</span>FIFO scope <span class="fcb">`t`</span> created<span class="fc5">)</span> </span></div><div class="t m0 x4 hc y307 ff6 fs4 fc6 sc0 ls0 ws0">|<span class="fc3">       </span>|<span class="fc3">            </span>|<span class="fc3">   +----------------+ <span class="fc5">(</span>task t.1<span class="fc5">)</span> </span></div><div class="t m0 x4 hc y308 ff6 fs4 fc6 sc0 ls0 ws0">|<span class="fc3">       </span>|<span class="fc3">            </span>|<span class="fc3">   +---+ <span class="fc5">(</span>task t.2<span class="fc5">)</span> </span>|<span class="fc3"> </span></div><div class="t m0 x4 hc y309 ff6 fs4 fc6 sc0 ls0 ws0">|<span class="fc3"> <span class="fc5">(</span>mid<span class="fc5">)</span> </span>|<span class="fc3">            </span>|<span class="fc3">   </span>|<span class="fc3">   </span>|<span class="fc3">            </span>|<span class="fc3"> </span></div><div class="t m0 x4 hc y30a ff6 fs4 fc4 sc0 ls0 ws0">:<span class="fc3">       <span class="fc6">|</span>            <span class="fc6">|</span>   + <span class="fc6">&lt;</span>-+------------+ <span class="fc5">(</span>scope <span class="fcb">`t`</span> ends<span class="fc5">)</span> </span></div><div class="t m0 x4 hc y30b ff6 fs4 fc4 sc0 ls0 ws0">:<span class="fc3">       <span class="fc6">|</span>            <span class="fc6">|</span>   <span class="fc6">|</span> </span></div><div class="t m0 x4 hc y30c ff6 fs4 fc6 sc0 ls0 ws0">|&lt;<span class="fc3">------+------------+---+ <span class="fc5">(</span>scope <span class="fcb">`s`</span> ends<span class="fc5">)</span> </span></div><div class="t m0 x4 hc y30d ff6 fs4 fc6 sc0 ls0 ws0">|<span class="fc3"> </span></div><div class="t m0 x4 hc y30e ff6 fs4 fc6 sc0 ls0 ws0">|<span class="fc3"> <span class="fc5">(</span>end<span class="fc5">)</span></span></div></div><div class="c x0 y30f w2 h1e"><div class="t m0 x2 h12 y310 ff4 fs3 fc0 sc0 ls0 ws0">send_wrapper</div><div class="t m0 x2 h6 y311 ff1 fs2 fc0 sc0 ls0 ws0">跨线程的变量必须实现<span class="ff5 fc1">Send<span class="fc0">,</span></span>否则不允许在跨线程使用，比如下面的代码：</div></div><div class="c x0 y312 w2 h3a"><div class="t m0 x4 hc y313 ff6 fs4 fc2 sc0 ls0 ws0">pub<span class="fc3"> </span>fn<span class="fc3"> <span class="fc4">wrong_send<span class="fc5">()</span></span> <span class="fc5">{</span> </span></div><div class="t m0 x4 hc y314 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> counter <span class="fc6">=</span> <span class="fc4">Rc<span class="fc5">::</span>new<span class="fc5">(<span class="fc7">42</span>);</span></span> </div><div class="t m0 x4 hc y315 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> <span class="fc5">(</span>sender<span class="fc5">,</span> receiver<span class="fc5">)</span> <span class="fc6">=</span> <span class="fc4">channel<span class="fc5">();</span></span> </div><div class="t m0 x4 hc y316 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> _t <span class="fc6">=</span> <span class="_ _2"> </span><span class="fc4">spawn<span class="fc5">(<span class="fc2">move</span></span></span> <span class="fc5">||</span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y317 ff6 fs4 fc3 sc0 ls0 ws0">        sender<span class="fc5">.<span class="fc4">send</span>(</span>counter<span class="fc5">).<span class="fc4">unwrap</span>();</span> </div><div class="t m0 x4 hc y318 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">});</span> </div><div class="t m0 x4 hc y319 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> value <span class="fc6">=</span> receiver<span class="fc5">.<span class="fc4">recv</span>().<span class="fc4">unwrap</span>();</span> </div><div class="t m0 x4 hc y31a ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc7">println!<span class="fc5">(<span class="fc8">&quot;received from the main thread: {}&quot;</span>,</span></span> value<span class="fc5">);</span> </div><div class="t m0 x4 hc y31b ff6 fs4 fc5 sc0 ls0 ws0">}</div></div><div class="c x0 y30f w2 h1e"><div class="t m0 x2 h6 y31c ff1 fs2 fc0 sc0 ls0 ws0">因为<span class="ff5">R<span class="_ _1"></span>c<span class="ff1">没有实现</span>Send,<span class="ff1">所以它不能直接在线程间使用。因为两个线程使用的</span>R<span class="_ _1"></span>c<span class="ff1">指向相同的引用计数</span></span></div><div class="t m0 x2 h6 y31d ff1 fs2 fc0 sc0 ls0 ws0">值，它们同时更新这个引用计数，并且没有使用原子操作，可能会导致意想不到的行为。可以通</div><div class="t m0 x2 h6 y31e ff1 fs2 fc0 sc0 ls0 ws0">过<span class="ff5">Arc</span>类型替换<span class="ff5">R<span class="_ _1"></span>c<span class="ff1">类型，也可以使用一个第三方的库，</span><span class="fc1">send_wrapper</span>,<span class="ff1">对它进行包装，以便实现</span></span></div><div class="t m0 x2 h2f y31f ff5 fs2 fc0 sc0 ls0 ws0">Sender:<span class="_ _3"> </span><span class="ff6 fs4">Send<span class="_ _3"> </span></span>.</div></div><div class="c xd y320 w4 he"><div class="t m0 x2 hc y321 ff6 fs4 fc3 sc0 ls0 ws0">thread<span class="fc5">::</span></div></div><a class="l" href="https://doc.rust-lang.org/std/marker/trait.Send.html"><div class="d m1" style="border-style:none;position:absolute;left:162.058731px;bottom:457.799960px;width:26.262829px;height:15.757500px;background-color:rgba(255,255,255,0.000001);"></div></a><a class="l" href="https://crates.io/crates/send_wrapper"><div class="d m1" style="border-style:none;position:absolute;left:324.138000px;bottom:170.409360px;width:73.535980px;height:15.757510px;background-color:rgba(255,255,255,0.000001);"></div></a></div><div class="pi" data-data='{"ctm":[1.000000,0.000000,0.000000,1.000000,0.000000,0.000000]}'></div></div>
<div id="pf18" class="pf w0 h0" data-page-no="18"><div class="pc pc18 w0 h0"><img class="bi x0 y322 w3 h3b" alt="" src="bg18.png"/><div class="c x0 yc7 w2 h2"><div class="t m0 x1 h3 y2 ff1 fs0 fc0 sc0 ls0 ws0">鸟窝<span class="ff2"> - https://github.com/smallnest/concurrency-programming-via-rust</span></div></div><div class="c x0 y115 w2 h3c"><div class="t m0 x4 hc y323 ff6 fs4 fc3 sc0 ls0 ws0">pub fn <span class="fc4">send_wrapper<span class="fc5">()</span></span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y324 ff6 fs4 fc3 sc0 ls0 ws0">    let wrapped_value <span class="fc6">=</span> SendWrapper<span class="fc5">::<span class="fc4">new</span>(</span>Rc<span class="fc5">::<span class="fc4">new</span>(<span class="fc7">42</span>));</span> </div><div class="t m0 x4 hc y325 ff6 fs4 fc3 sc0 ls0 ws0">    let <span class="fc5">(</span>sender<span class="fc5">,</span> receiver<span class="fc5">)</span> <span class="fc6">=</span> <span class="fc4">channel<span class="fc5">();</span></span> </div><div class="t m0 x4 hc y326 ff6 fs4 fc3 sc0 ls0 ws0">    let _t <span class="fc6">=</span> thread<span class="fc5">::<span class="fc4">spawn</span>(</span>move <span class="fc6">||</span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y327 ff6 fs4 fc3 sc0 ls0 ws0">        sender<span class="fc5">.<span class="fc4">send</span>(</span>wrapped_value<span class="fc5">).<span class="fc4">unwrap</span>();</span> </div><div class="t m0 x4 hc y328 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">});</span> </div><div class="t m0 x4 hc y329 ff6 fs4 fc3 sc0 ls0 ws0">    let wrapped_value <span class="fc6">=</span> receiver<span class="fc5">.<span class="fc4">recv</span>().<span class="fc4">unwrap</span>();</span> </div><div class="t m0 x4 hc y32a ff6 fs4 fc3 sc0 ls0 ws0">    let value <span class="fc6">=</span> wrapped_value<span class="fc5">.<span class="fc4">deref</span>();</span> </div><div class="t m0 x4 hc y32b ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc8">println<span class="fc6">!<span class="fc5">(</span></span>&quot;received from the main thread: {}&quot;<span class="fc5">,</span></span> value<span class="fc5">);</span> </div><div class="t m0 x4 hc y32c ff6 fs4 fc5 sc0 ls0 ws0">}</div></div><div class="c x0 y32d w2 h3d"><div class="t m0 x2 h6 y32e ff1 fs2 fc0 sc0 ls0 ws0">我们把<span class="ff5">R<span class="_ _1"></span>c<span class="ff1">的值包装到一个</span>wrapper_value<span class="ff1">值中，就可以在线程中使用了。</span></span></div><div class="t m0 x2 ha y32f ff4 fs3 fc0 sc0 ls0 ws0">Go<span class="ff3">风格的启动线程</span></div><div class="t m0 x2 h6 y330 ff1 fs2 fc0 sc0 ls0 ws0">你了解过<span class="ff5">Go</span>语言吗？如果你稍微看过<span class="ff5">Go</span>语言，就会发现它的开启新的<span class="ff5">goroutine</span>的方法非常的简</div><div class="t m0 x2 h6 y331 ff1 fs2 fc0 sc0 ls0 ws0">洁，通过<span class="ff5"> <span class="_ _3"> </span><span class="ff6 fs4">go func() {...}()<span class="_ _3"> </span></span></span>就启动了一个<span class="ff5">goroutine</span>，貌似同步的代码，却是异步的执行。</div><div class="t m0 x2 h6 y332 ff1 fs2 fc0 sc0 ls0 ws0">有一个第三方的库<span class="ff5"> <span class="fc1">go-spawn</span></span>，可以提供<span class="ff5">Go</span>类似的便利的方法<span class="ff5">:</span></div></div><div class="c x0 y333 w2 h3e"><div class="t m0 x4 hc y334 ff6 fs4 fc2 sc0 ls0 ws0">pub<span class="fc3"> </span>fn<span class="fc3"> <span class="fc4">go_thread<span class="fc5">()</span></span> <span class="fc5">{</span> </span></div><div class="t m0 x4 hc y335 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> counter <span class="fc6">=</span> <span class="fc4">Arc<span class="fc5">::</span>new<span class="fc5">(</span>AtomicI64<span class="fc5">::</span>new<span class="fc5">(<span class="fc7">0</span>));</span></span> </div><div class="t m0 x4 hc y336 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc2">let</span> counter_cloned <span class="fc6">=</span> counter<span class="fc5">.<span class="fc4">clone</span>();</span> </div><div class="t m0 x4 hc y337 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc9">// Spawn a thread that captures values by move.</span> </div><div class="t m0 x4 hc y338 ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc7">go!</span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y339 ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc2">for</span> _ <span class="fc2">in</span> <span class="fc7">0<span class="fc5">..</span>100</span> <span class="fc5">{</span> </div><div class="t m0 x4 hc y33a ff6 fs4 fc3 sc0 ls0 ws0">            counter_cloned<span class="fc5">.<span class="fc4">fetch_add</span>(<span class="fc7">1</span>,</span> <span class="fc4">Ordering<span class="fc5">::</span>SeqCst<span class="fc5">);</span></span> </div><div class="t m0 x4 hc y33b ff6 fs4 fc3 sc0 ls0 ws0">        <span class="fc5">}</span> </div><div class="t m0 x4 hc y33c ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc5">}</span> </div><div class="t m0 x4 hc y33d ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc9">// Join the most recent thread spawned by `go_spawn` that has not yet been joined.</span> </div><div class="t m0 x4 hc y33e ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc7">assert!<span class="fc5">(</span>join!<span class="fc5">().<span class="fc4">is_ok</span>());</span></span> </div><div class="t m0 x4 hc y33f ff6 fs4 fc3 sc0 ls0 ws0">    <span class="fc7">assert_eq!<span class="fc5">(</span></span>counter<span class="fc5">.<span class="fc4">load</span>(<span class="fc4">Ordering</span>::<span class="fc4">SeqCst</span>),</span> <span class="fc7">100<span class="fc5">);</span></span> </div><div class="t m0 x4 hc y340 ff6 fs4 fc5 sc0 ls0 ws0">}</div></div><div class="c x0 y32d w2 h3d"><div class="t m0 x2 h6 y341 ff1 fs2 fc0 sc0 ls0 ws0">通过宏<span class="_ _3"> </span><span class="ff6 fs4">go!<span class="_ _3"> </span></span>启动一个线程，使用<span class="_ _3"> </span><span class="ff6 fs4">join!<span class="_ _3"> </span></span>把最近<span class="ff5">go_spawn</span>创建的线程<span class="ff5">join</span>起来，看起来也非常的简</div><div class="t m0 x2 h6 y342 ff1 fs2 fc0 sc0 ls0 ws0">洁。虽然关注度不高，但是我觉得它是一个非常有趣的库。</div></div><a class="l" href="https://crates.io/crates/go-spawn"><div class="d m1" style="border-style:none;position:absolute;left:141.048447px;bottom:408.275600px;width:53.276063px;height:15.757480px;background-color:rgba(255,255,255,0.000001);"></div></a></div><div class="pi" data-data='{"ctm":[1.000000,0.000000,0.000000,1.000000,0.000000,0.000000]}'></div></div>
</div>
<div class="loading-indicator">

</div>
</body>
</html>
